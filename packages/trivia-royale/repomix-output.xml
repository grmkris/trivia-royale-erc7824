This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
game/
  PlayerGameClient.ts
  ServerGameClient.ts
  types.ts
  utils.ts
utils/
  channels.ts
  clearnode.ts
  contracts.ts
  erc20.ts
  keyManager.ts
  state-tracker.ts
  wallets.ts
cashout.ts
e2e-flow.ts
env.ts
fund.ts
play.ts
prepare.ts
status.ts
test-clearnode.ts
test-config.ts
yellow-integration.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="game/PlayerGameClient.ts">
/**
 * Player Game Client
 *
 * Factory function that creates a player-side game controller.
 * Handles receiving questions, submitting commits/reveals, and listening for results.
 *
 * Two modes:
 * 1. Demo mode (mockConfig provided): Auto-responds with predetermined answers
 * 2. Production mode (no mockConfig): Use onQuestion/onRevealRequest callbacks for user input
 *
 * Usage:
 *   // Demo mode:
 *   const player = createPlayerClient({ ws, signer, wallet, mockConfig })
 *   await player.start()
 *
 *   // Production mode:
 *   const player = createPlayerClient({ ws, signer, wallet })
 *   player.onQuestion(async (question, deadline) => {
 *     const answer = await getUserInput()
 *     await player.submitCommit(sessionId, answer)
 *   })
 *   await player.start()
 */

import type { Address, Hex } from 'viem';
import { parseAnyRPCResponse, RPCMethod } from '@erc7824/nitrolite';
import { sendGameMessage, type MessageSigner } from '../yellow-integration';
import {
  generateSecret,
  createCommitment,
  delay,
} from './utils';
import type {
  QuestionMessage,
  CommitMessage,
  RevealRequestMessage,
  RevealMessage,
  RoundResultMessage,
  PlayerMockConfig,
} from './types';
import { parseGameMessage } from './types';
import type { Wallet } from '../utils/wallets';
import { DEBUG } from '../env';

// ==================== TYPES ====================

export interface PlayerClientParams {
  ws: WebSocket;
  signer: MessageSigner;
  wallet: Wallet;
  mockConfig?: PlayerMockConfig; // Optional: for demo mode
}

export interface PlayerGameClient {
  start(): Promise<void>;
  onQuestion(handler: (question: QuestionMessage) => void | Promise<void>): void;
  onRevealRequest(handler: (request: RevealRequestMessage) => void | Promise<void>): void;
  onRoundResult(handler: (result: RoundResultMessage) => void | Promise<void>): void;
  submitCommit(sessionId: Hex, answer: string): Promise<void>;
  submitReveal(sessionId: Hex): Promise<void>;
  cleanup(): void;
}

// ==================== FACTORY ====================

export function createPlayerClient({
  ws,
  signer,
  wallet,
  mockConfig,
}: PlayerClientParams): PlayerGameClient {
  // Internal state
  let messageHandler: ((event: MessageEvent) => void) | null = null;
  let questionHandler: ((question: QuestionMessage) => void | Promise<void>) | null = null;
  let revealRequestHandler: ((request: RevealRequestMessage) => void | Promise<void>) | null = null;
  let roundResultHandler: ((result: RoundResultMessage) => void | Promise<void>) | null = null;

  let currentSessionId: Hex | null = null;
  let currentAnswer: string | null = null;
  let currentSecret: Hex | null = null;
  let currentCommitment: Hex | null = null;
  let currentRound = 0;

  // ==================== MESSAGE HANDLING ====================

  function handleIncomingMessage(event: MessageEvent) {
    try {
      const response = parseAnyRPCResponse(event.data);

      // Handle application messages from ClearNode
      if (response.method === RPCMethod.Message) {
        const { message, app_session_id } = response.params as { message: unknown, app_session_id: Hex };
        // Skip empty success responses (no message content)
        if (!message || !app_session_id) {
          return;
        }

        // Store session ID
        if (app_session_id) {
          currentSessionId = app_session_id;
        }
        const gameMsg = parseGameMessage(message);

        // Route by message type (TypeScript knows the exact type per case)
        switch (gameMsg.type) {
          case 'question':
            handleQuestionMessage(gameMsg);
            break;
          case 'reveal_request':
            handleRevealRequestMessage(gameMsg);
            break;
          case 'round_result':
            handleRoundResultMessage(gameMsg);
            break;
        }
      }
    } catch (error) {
      console.error(`  ‚ùå ${wallet.name}: Error handling message:`, error);
      if (error instanceof Error) {
        console.error(`  üìã Error details:`, error.message);
      }
    }
  }

  async function handleQuestionMessage(msg: QuestionMessage) {
    currentRound = msg.round;
    console.log(`  üì• ${wallet.name}: Received question for round ${msg.round}`);

    // Call user handler if registered
    if (questionHandler) {
      await questionHandler(msg);
      return;
    }

    // Demo mode: auto-respond
    if (mockConfig && currentSessionId) {
      const mockAnswer = mockConfig.answers[msg.round - 1];
      if (mockAnswer) {
        await delay(mockAnswer.delay);
        await submitCommit(currentSessionId, mockAnswer.answer);
      }
    }
  }

  async function handleRevealRequestMessage(msg: RevealRequestMessage) {
    console.log(`  üì• ${wallet.name}: Received reveal request for round ${msg.round}`);

    // Call user handler if registered
    if (revealRequestHandler) {
      await revealRequestHandler(msg);
      return;
    }

    // Demo mode: auto-reveal
    if (mockConfig && currentSessionId) {
      await submitReveal(currentSessionId);
    }
  }

  async function handleRoundResultMessage(msg: RoundResultMessage) {
    console.log(`  üì• ${wallet.name}: Received round result for round ${msg.round}`);

    // Call user handler if registered
    if (roundResultHandler) {
      await roundResultHandler(msg);
    }
  }

  // ==================== PUBLIC API ====================

  async function start(): Promise<void> {
    console.log(`  üéÆ ${wallet.name}: Starting...`);
    messageHandler = handleIncomingMessage;
    ws.addEventListener('message', messageHandler);
    console.log(`  ‚úÖ ${wallet.name}: Ready`);
  }

  function onQuestion(handler: (question: QuestionMessage) => void | Promise<void>) {
    questionHandler = handler;
  }

  function onRevealRequest(handler: (request: RevealRequestMessage) => void | Promise<void>) {
    revealRequestHandler = handler;
  }

  function onRoundResult(handler: (result: RoundResultMessage) => void | Promise<void>) {
    roundResultHandler = handler;
  }

  async function submitCommit(sessionId: Hex, answer: string): Promise<void> {
    const secret = generateSecret();
    const commitment = createCommitment(answer, secret, wallet.address);

    // Store for reveal phase
    currentAnswer = answer;
    currentSecret = secret;
    currentCommitment = commitment;

    const commitMsg: CommitMessage = {
      type: 'commit',
      playerAddress: wallet.address,
      commitment,
      timestamp: Date.now(),
    };

    await sendGameMessage(ws, signer, sessionId, commitMsg);
    console.log(`  ‚úÖ ${wallet.name}: Submitted commit`);
  }

  async function submitReveal(sessionId: Hex): Promise<void> {
    if (!currentAnswer || !currentSecret || !currentCommitment) {
      console.error(`  ‚ùå ${wallet.name}: No stored answer to reveal`);
      return;
    }

    const revealMsg: RevealMessage = {
      type: 'reveal',
      playerAddress: wallet.address,
      answer: currentAnswer,
      secret: currentSecret,
      commitment: currentCommitment,
    };

    await sendGameMessage(ws, signer, sessionId, revealMsg);
    console.log(`  ‚úÖ ${wallet.name}: Submitted reveal`);
  }

  function cleanup() {
    if (messageHandler) {
      ws.removeEventListener('message', messageHandler);
      messageHandler = null;
    }
    questionHandler = null;
    revealRequestHandler = null;
    roundResultHandler = null;
    currentAnswer = null;
    currentSecret = null;
    currentCommitment = null;
    console.log(`  üßπ ${wallet.name}: Cleaned up`);
  }

  // Return public API
  return {
    start,
    onQuestion,
    onRevealRequest,
    onRoundResult,
    submitCommit,
    submitReveal,
    cleanup,
  };
}
</file>

<file path="game/ServerGameClient.ts">
/**
 * Server Game Client
 *
 * Factory function that creates a server-side game controller.
 * Handles game flow, message broadcasting, and result aggregation.
 *
 * Usage:
 *   const server = createServerClient({ ws, signer, participants, serverAddress })
 *   await server.start()
 *   const sessionId = await server.createGame(allocations)
 *   await server.broadcastQuestion(sessionId, question, 1)
 *   const commits = await server.collectCommits(5000)
 *   // ... game logic
 *   await server.cleanup()
 */

import type { Address, Hex } from 'viem';
import { parseAnyRPCResponse, RPCMethod } from '@erc7824/nitrolite';
import {
  createGameSession,
  sendGameMessage,
  closeGameSession,
  type MessageSigner,
} from '../yellow-integration';
import {
  verifyCommitment,
  generateSecret,
  createCommitment,
} from './utils';
import type {
  QuestionMessage,
  CommitMessage,
  RevealRequestMessage,
  RevealMessage,
  RoundResultMessage,
  CommitData,
  RevealData,
  RoundWinner,
} from './types';
import { parseGameMessage } from './types';
import { DEBUG } from '../env';

// ==================== TYPES ====================

export interface ServerClientParams {
  ws: WebSocket;
  signer: MessageSigner;
  participants: Address[];
  serverAddress: Address;
}

export interface ServerGameClient {
  start(): Promise<void>;
  createGame(allocations: Array<{
    participant: Address;
    asset: string;
    amount: string;
  }>): Promise<Hex>;
  broadcastQuestion(sessionId: Hex, question: string, round: number, commitTimeoutMs: number): Promise<number>;
  collectCommits(questionSentAt: number, timeoutMs: number): Promise<Map<Address, CommitData>>;
  requestReveals(sessionId: Hex, round: number): Promise<void>;
  collectReveals(questionSentAt: number, timeoutMs: number): Promise<Map<Address, RevealData>>;
  determineWinner(reveals: Map<Address, RevealData>, correctAnswer: string): RoundWinner | null;
  broadcastResult(sessionId: Hex, round: number, winner: RoundWinner | null, correctAnswer: string): Promise<void>;
  endGame(sessionId: Hex, finalAllocations: Array<{
    participant: Address;
    asset: string;
    amount: string;
  }>): Promise<void>;
  cleanup(): void;
}

// ==================== FACTORY ====================

export function createServerClient({
  ws,
  signer,
  participants,
  serverAddress,
}: ServerClientParams): ServerGameClient {
  // Internal state
  const commitBuffer = new Map<Address, CommitData>();
  const revealBuffer = new Map<Address, RevealData>();
  let messageHandler: ((event: MessageEvent) => void) | null = null;

  // ==================== MESSAGE HANDLING ====================

  function handleIncomingMessage(event: MessageEvent) {
    try {
      const response = parseAnyRPCResponse(event.data);

      // Handle RPC errors from ClearNode
      if (response.method === RPCMethod.Error) {
        console.error(`  ‚ùå Server: ClearNode Error:`, JSON.stringify(response.params, null, 2));
        return;
      }

      // Handle application messages from ClearNode (broadcast from other participants)
      if (response.method === RPCMethod.Message) {
        const { message, app_session_id } = response.params;

        // Skip empty success responses (no message content)
        if (!message || !app_session_id) {
          if (DEBUG) {
            console.log(`  üîç Server: Empty message received`);
          }
          return;
        }

        // Parse and validate game message with Zod
        const rawMsg = typeof message === 'string' ? JSON.parse(message) : message;

        if (DEBUG) {
          console.log(`  üîç Server: App message received, session: ${app_session_id?.slice(0, 10)}...`);
          console.log(`  üîç Server: Raw message type: ${rawMsg.type}`);
        }

        const gameMsg = parseGameMessage(rawMsg);

        // Route by message type (TypeScript knows the exact type per case)
        switch (gameMsg.type) {
          case 'commit':
            handleCommitMessage(gameMsg);
            break;
          case 'reveal':
            handleRevealMessage(gameMsg);
            break;
        }
      }
    } catch (error) {
      console.error('  ‚ùå Server: Error handling message:', error);
      if (error instanceof Error) {
        console.error('  üìã Error details:', error.message);
      }
    }
  }

  function handleCommitMessage(msg: CommitMessage) {
    const receivedAt = Date.now();
    commitBuffer.set(msg.playerAddress, {
      commitment: msg.commitment,
      timestamp: msg.timestamp,
      receivedAt,
    });
  }

  function handleRevealMessage(msg: RevealMessage) {
    revealBuffer.set(msg.playerAddress, {
      answer: msg.answer,
      secret: msg.secret,
      commitment: msg.commitment,
      isValid: false, // Will be verified
      isCorrect: false, // Will be checked
      responseTime: 0, // Will be calculated
    });
  }

  // ==================== PUBLIC API ====================

  async function start(): Promise<void> {
    console.log('  üéÆ Server: Starting...');
    messageHandler = handleIncomingMessage;
    ws.addEventListener('message', messageHandler);
    console.log('  ‚úÖ Server: Ready');
  }

  async function createGame(allocations: Array<{
    participant: Address;
    asset: string;
    amount: string;
  }>): Promise<Hex> {
    const session = await createGameSession(
      ws,
      signer,
      participants,
      allocations,
      serverAddress,
      'NitroRPC/0.4'
    );
    return session.sessionId;
  }

  async function broadcastQuestion(
    sessionId: Hex,
    question: string,
    round: number,
    commitTimeoutMs: number
  ): Promise<number> {
    const timestamp = Date.now();
    const questionMsg: QuestionMessage = {
      type: 'question',
      round,
      question,
      timestamp,
      commitDeadline: timestamp + commitTimeoutMs,
    };

    await sendGameMessage(ws, signer, sessionId, questionMsg);
    console.log(`  üì§ Server: Broadcasted question for round ${round}`);
    return timestamp;
  }

  async function collectCommits(
    questionSentAt: number,
    timeoutMs: number
  ): Promise<Map<Address, CommitData>> {
    commitBuffer.clear();

    return new Promise((resolve) => {
      setTimeout(() => {
        const collected = new Map(commitBuffer);
        console.log(`  üì• Server: Collected ${collected.size} commits`);
        resolve(collected);
      }, timeoutMs);
    });
  }

  async function requestReveals(sessionId: Hex, round: number): Promise<void> {
    const revealMsg: RevealRequestMessage = {
      type: 'reveal_request',
      round,
    };

    await sendGameMessage(ws, signer, sessionId, revealMsg);
    console.log(`  üì§ Server: Requested reveals for round ${round}`);
  }

  async function collectReveals(
    questionSentAt: number,
    timeoutMs: number
  ): Promise<Map<Address, RevealData>> {
    revealBuffer.clear();

    return new Promise((resolve) => {
      setTimeout(() => {
        const collected = new Map(revealBuffer);

        // Verify each reveal
        for (const [address, reveal] of collected) {
          // Verify commitment
          reveal.isValid = verifyCommitment(
            reveal.answer,
            reveal.secret,
            address,
            reveal.commitment
          );

          // Calculate response time (from question sent to commit received)
          const commitData = commitBuffer.get(address);
          if (commitData) {
            reveal.responseTime = commitData.receivedAt - questionSentAt;
          }
        }

        console.log(`  üì• Server: Collected ${collected.size} reveals`);
        resolve(collected);
      }, timeoutMs);
    });
  }

  function determineWinner(
    reveals: Map<Address, RevealData>,
    correctAnswer: string
  ): RoundWinner | null {
    const correctReveals: Array<{ address: Address; time: number }> = [];

    // Filter correct answers
    for (const [address, reveal] of reveals) {
      if (!reveal.isValid) {
        console.log(`  ‚ùå Invalid reveal from ${address.slice(0, 10)}...`);
        continue;
      }

      reveal.isCorrect = reveal.answer === correctAnswer;
      if (reveal.isCorrect) {
        correctReveals.push({
          address,
          time: reveal.responseTime,
        });
      }
    }

    if (correctReveals.length === 0) {
      return null;
    }

    // Sort by response time (fastest first)
    correctReveals.sort((a, b) => a.time - b.time);
    const winner = correctReveals[0];

    if (!winner) return null;

    return {
      playerAddress: winner.address,
      playerName: '', // Will be filled by caller
      responseTime: winner.time,
    };
  }

  async function broadcastResult(
    sessionId: Hex,
    round: number,
    winner: RoundWinner | null,
    correctAnswer: string
  ): Promise<void> {
    const resultMsg: RoundResultMessage = {
      type: 'round_result',
      round,
      winner: winner ? winner.playerAddress : null,
      correctAnswer,
    };

    await sendGameMessage(ws, signer, sessionId, resultMsg);
  }

  async function endGame(sessionId: Hex, finalAllocations: Array<{
    participant: Address;
    asset: string;
    amount: string;
  }>): Promise<void> {
    await closeGameSession(ws, signer, sessionId, finalAllocations);
    console.log('  ‚úÖ Server: Game ended');
  }

  function cleanup() {
    if (messageHandler) {
      ws.removeEventListener('message', messageHandler);
      messageHandler = null;
    }
    commitBuffer.clear();
    revealBuffer.clear();
    console.log('  üßπ Server: Cleaned up');
  }

  // Return public API
  return {
    start,
    createGame,
    broadcastQuestion,
    collectCommits,
    requestReveals,
    collectReveals,
    determineWinner,
    broadcastResult,
    endGame,
    cleanup,
  };
}
</file>

<file path="game/types.ts">
/**
 * Game Message Types
 *
 * Protocol for client-server game communication via ClearNode
 * Uses Zod for runtime validation and type safety
 */

import { z } from 'zod';
import type { Address, Hex } from 'viem';

// ==================== ZOD SCHEMAS ====================

/**
 * Zod schema for Ethereum addresses (0x + 40 hex chars)
 */
const AddressSchema = z.string().regex(/^0x[a-fA-F0-9]{40}$/) as z.Schema<Address>;

/**
 * Zod schema for Hex strings (0x + hex chars)
 */
const HexSchema = z.string().regex(/^0x[a-fA-F0-9]+$/) as z.Schema<Hex>;

/**
 * Server ‚Üí Players: Question broadcast
 */
export const QuestionMessageSchema = z.object({
  type: z.literal('question'),
  round: z.number().int().positive(),
  question: z.string().min(1),
  timestamp: z.number().int().nonnegative(),
  commitDeadline: z.number().int().nonnegative(),
});

/**
 * Player ‚Üí Server: Commitment submission
 */
export const CommitMessageSchema = z.object({
  type: z.literal('commit'),
  playerAddress: AddressSchema,
  commitment: HexSchema,
  timestamp: z.number().int().nonnegative(),
});

/**
 * Server ‚Üí Players: Request reveals
 */
export const RevealRequestMessageSchema = z.object({
  type: z.literal('reveal_request'),
  round: z.number().int().positive(),
});

/**
 * Player ‚Üí Server: Answer reveal
 */
export const RevealMessageSchema = z.object({
  type: z.literal('reveal'),
  playerAddress: AddressSchema,
  answer: z.string(),
  secret: HexSchema,
  commitment: HexSchema,
});

/**
 * Server ‚Üí Players: Round result
 */
export const RoundResultMessageSchema = z.object({
  type: z.literal('round_result'),
  round: z.number().int().positive(),
  winner: AddressSchema.nullable(),
  correctAnswer: z.string(),
});

/**
 * Discriminated union of all game messages
 */
export const GameMessageSchema = z.discriminatedUnion('type', [
  QuestionMessageSchema,
  CommitMessageSchema,
  RevealRequestMessageSchema,
  RevealMessageSchema,
  RoundResultMessageSchema,
]);

/**
 * Parse and validate a game message
 * @throws {z.ZodError} if message is invalid
 */
export function parseGameMessage(data: unknown): GameMessage {
  return GameMessageSchema.parse(data);
}

/**
 * Safely parse a game message (returns result object)
 */
export function safeParseGameMessage(data: unknown) {
  return GameMessageSchema.safeParse(data);
}

// ==================== GAME MESSAGES (TypeScript Types) ====================

/**
 * Server ‚Üí Players: Question broadcast
 * Inferred from QuestionMessageSchema
 */
export type QuestionMessage = z.infer<typeof QuestionMessageSchema>;

/**
 * Player ‚Üí Server: Commitment submission
 * Inferred from CommitMessageSchema
 */
export type CommitMessage = z.infer<typeof CommitMessageSchema>;

/**
 * Server ‚Üí Players: Request reveals
 * Inferred from RevealRequestMessageSchema
 */
export type RevealRequestMessage = z.infer<typeof RevealRequestMessageSchema>;

/**
 * Player ‚Üí Server: Answer reveal
 * Inferred from RevealMessageSchema
 */
export type RevealMessage = z.infer<typeof RevealMessageSchema>;

/**
 * Server ‚Üí Players: Round result
 * Inferred from RoundResultMessageSchema
 */
export type RoundResultMessage = z.infer<typeof RoundResultMessageSchema>;

/**
 * Union of all game messages
 * Inferred from GameMessageSchema
 */
export type GameMessage = z.infer<typeof GameMessageSchema>;

// ==================== GAME STATE ====================

/**
 * Commit data collected by server
 */
export interface CommitData {
  commitment: Hex;
  timestamp: number;
  receivedAt: number;
}

/**
 * Reveal data collected by server
 */
export interface RevealData {
  answer: string;
  secret: Hex;
  commitment: Hex;
  isValid: boolean;
  isCorrect: boolean;
  responseTime: number;
}

/**
 * Round winner information
 */
export interface RoundWinner {
  playerAddress: Address;
  playerName: string;
  responseTime: number;
}

/**
 * Game results
 */
export interface GameResults {
  wins: Map<string, number>;
}

/**
 * Prize distribution
 */
export interface PrizeDistribution {
  name: string;
  wins: number;
  prize: string;
  change: string;
}

// ==================== MOCK CONFIG ====================

/**
 * Mock configuration for automated player responses (demo mode)
 */
export interface PlayerMockConfig {
  answers: Array<{
    answer: string;
    delay: number;
  }>;
}
</file>

<file path="game/utils.ts">
/**
 * Game Utilities
 *
 * Shared helper functions for commitment protocol and game logic
 */

import { keccak256, encodePacked, type Hex, type Address } from 'viem';

// ==================== COMMITMENT PROTOCOL ====================

/**
 * Generate a cryptographically secure random secret
 */
export function generateSecret(): Hex {
  const bytes = crypto.getRandomValues(new Uint8Array(32));
  return `0x${Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('')}`;
}

/**
 * Create a commitment hash from answer, secret, and player address
 * Uses keccak256(abi.encodePacked(answer, secret, address))
 */
export function createCommitment(
  answer: string,
  secret: Hex,
  address: Address
): Hex {
  return keccak256(encodePacked(['string', 'bytes32', 'address'], [answer, secret, address]));
}

/**
 * Verify a commitment matches the revealed answer and secret
 */
export function verifyCommitment(
  answer: string,
  secret: Hex,
  address: Address,
  commitment: Hex
): boolean {
  const expected = createCommitment(answer, secret, address);
  return expected === commitment;
}

// ==================== TIMING ====================

/**
 * Async delay helper
 */
export function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
</file>

<file path="utils/channels.ts">
import { NitroliteClient, WalletStateSigner, getChannelId } from '@erc7824/nitrolite';
import { SessionKeyStateSigner } from '@erc7824/nitrolite/dist/client/signer';
import { parseEther } from 'viem';
import { SEPOLIA_CONFIG } from './contracts';
import { createPublicRpcClient, type Wallet } from './wallets';

/**
 * Create NitroliteClient for a wallet
 *
 * Uses SessionKeyStateSigner to sign states with the wallet's session key.
 * This matches ClearNode's expectation that states are signed by the session key
 * address provided during authentication and channel creation.
 */
export function createNitroliteClient(
  playerWallet: Wallet,
  serverAddress: `0x${string}`
): NitroliteClient {
  const publicClient = createPublicRpcClient();

  // Use session key for state signing (matches SDK integration tests pattern)
  const stateSigner = new SessionKeyStateSigner(playerWallet.sessionPrivateKey);

  return new NitroliteClient({
    publicClient,
    walletClient: playerWallet.client,
    stateSigner,
    challengeDuration: 3600n,
    addresses: {
      custody: SEPOLIA_CONFIG.contracts.custody,
      adjudicator: SEPOLIA_CONFIG.contracts.adjudicator,
      guestAddress: serverAddress,
    },
    chainId: SEPOLIA_CONFIG.chainId,
  });
}

/**
 * Check if channel exists between player and server
 */
export async function findChannel(
  playerAddress: `0x${string}`,
  serverAddress: `0x${string}`,
  playerNitroliteClient: NitroliteClient,
): Promise<string | null> {
  try {
    const publicClient = createPublicRpcClient();

    // Get all open channels for the player
    const channelIds = await playerNitroliteClient.getOpenChannels();

    // Check each channel to see if it's between player and server
    for (const channelId of channelIds) {
      const channelData = await playerNitroliteClient.getChannelData(channelId);
      const participants = channelData.channel.participants;

      // Check if both player and server are participants
      const hasPlayer = participants.some(
        (addr) => addr.toLowerCase() === playerAddress.toLowerCase()
      );
      const hasServer = participants.some(
        (addr) => addr.toLowerCase() === serverAddress.toLowerCase()
      );

      if (hasPlayer && hasServer) {
        return channelId;
      }
    }

    return null;
  } catch (error) {
    console.error('Error finding channel:', error);
    return null;
  }
}

/**
 * Create channel for player ‚Üí server
 */
export async function createChannel(
  playerWallet: Wallet,
  serverWallet: Wallet,
  amount: string
): Promise<string> {
  const playerClient = createNitroliteClient(playerWallet, serverWallet.address);
  const serverClient = createNitroliteClient(serverWallet, playerWallet.address);
  const amountWei = parseEther(amount);

  console.log(`  üí∞ ${playerWallet.name}: Depositing ${amount} ETH...`);

  // Build channel parameters
  const channelParams = {
    participants: [playerWallet.address, serverWallet.address],
    adjudicator: SEPOLIA_CONFIG.contracts.adjudicator,
    challenge: 3600n,
    nonce: BigInt(Date.now()),
  };

  // Build unsigned initial state
  const unsignedInitialState = {
    intent: 1, // INITIALIZE
    version: 0n,
    data: '0x' as const,
    allocations: [
      {
        destination: playerWallet.address,
        token: SEPOLIA_CONFIG.contracts.tokenAddress,
        amount: amountWei,
      },
      {
        destination: serverWallet.address,
        token: SEPOLIA_CONFIG.contracts.tokenAddress,
        amount: 0n,
      },
    ],
  };

  // Compute channel ID
  const channelId = getChannelId(channelParams, SEPOLIA_CONFIG.chainId);

  // Server signs the initial state
  // Convert unsigned state to State with empty sigs for signing
  const stateToSign = {
    ...unsignedInitialState,
    sigs: [] as `0x${string}`[],
  };

  const serverSigner = new WalletStateSigner(serverWallet.client);
  const serverSignature = await serverSigner.signState(
    channelId,
    stateToSign
  );

  // Player creates channel with server's signature
  const result = await playerClient.depositAndCreateChannel(
    SEPOLIA_CONFIG.contracts.tokenAddress,
    amountWei,
    {
      channel: channelParams,
      unsignedInitialState,
      serverSignature,
    }
  );

  console.log(`  ‚úÖ ${playerWallet.name}: Channel created (${result.channelId.slice(0, 10)}...)`);
  return result.channelId;
}

/**
 * Ensure channel exists, create if needed
 */
export async function ensureChannel(
  props: {
    playerNitroliteClient: NitroliteClient,
  playerWallet: Wallet,
  serverWallet: Wallet,
  amount: string
  }
): Promise<string> {
  const { playerNitroliteClient, playerWallet, serverWallet, amount } = props;
  // Check existing
  const existing = await findChannel(playerWallet.address, serverWallet.address, playerNitroliteClient);

  if (existing) {
    console.log(`  ‚úÖ ${playerWallet.name}: Channel exists (${existing.slice(0, 10)}...)`);
    return existing;
  }

  // Create new
  return createChannel(playerWallet, serverWallet, amount);
}
</file>

<file path="utils/clearnode.ts">
/**
 * ClearNode WebSocket Management
 *
 * Functional helpers for managing multiple WebSocket connections
 * to Yellow Network's ClearNode service.
 */


// @ts-expect-error BigInt.prototype["toJSON"] is not defined
BigInt.prototype["toJSON"] = function () {
  return this.toString();
};

import {
  connectToClearNode,
  authenticateClearNode,
  createMessageSigner,
} from '../yellow-integration';
import {
  createGetLedgerBalancesMessage,
  createCreateChannelMessage,
  createGetChannelsMessage,
  createResizeChannelMessage,
  createCloseChannelMessage,
  createTransferMessage,
  parseAnyRPCResponse,
  parseCreateChannelResponse,
  parseGetChannelsResponse,
  parseResizeChannelResponse,
  parseCloseChannelResponse,
  convertRPCToClientChannel,
  convertRPCToClientState,
  RPCMethod,
  type CreateChannelRequestParams,
  type UnsignedState,
  RPCChannelStatus,
  parseChannelUpdateResponse,
} from '@erc7824/nitrolite';
import { SEPOLIA_CONFIG } from './contracts';
import type { Wallet } from './wallets';
import type { Address, Hex } from 'viem';
import { createWalletClient, http, parseUnits } from 'viem';
import { createNitroliteClient } from './channels';
import { sepolia } from 'viem/chains';
import { privateKeyToAccount } from 'viem/accounts';
import { parseUSDC, ensureAllowance } from './erc20';

/**
 * Connect and authenticate all participants to ClearNode
 */
export async function connectAllParticipants(
  wallets: Wallet[]
): Promise<Map<string, WebSocket>> {
  const connections = new Map<string, WebSocket>();

  for (const wallet of wallets) {
    console.log(`   üîó ${wallet.name}: Connecting...`);

    const ws = await connectToClearNode(SEPOLIA_CONFIG.clearNodeUrl);
    await authenticateClearNode(ws, wallet);

    connections.set(wallet.name, ws);
    console.log(`   ‚úÖ ${wallet.name}: Authenticated`);
  }

  return connections;
}

/**
 * Create a channel via ClearNode RPC
 *
 * This creates a channel AND registers it with ClearNode for ledger tracking.
 * The channel will be between the wallet and ClearNode (as broker/counterparty).
 *
 * Flow:
 * 1. Deposit funds to custody contract
 * 2. Send RPC request to ClearNode ‚Üí Get broker-signed state
 * 3. Parse response to extract channel, state, serverSignature
 * 4. Create NitroliteClient and submit blockchain transaction
 * 5. Wait for transaction confirmation
 * 6. ClearNode detects ChannelCreated event ‚Üí populates ledger balances
 */
export async function createChannelViaRPC(
  ws: WebSocket,
  wallet: Wallet,
  amount: string = '10' // Default amount in USDC
): Promise<Hex> {
  return new Promise(async (resolve, reject) => {
    try {
      // Step 1: Approve custody contract to spend USDC
      const amountWei = parseUSDC(amount);
      await ensureAllowance(wallet, SEPOLIA_CONFIG.contracts.custody, amountWei);

      // Step 2: Deposit funds to custody contract
      // Create NitroliteClient with broker as counterparty for the 2-party state channel
      const nitroliteClient = createNitroliteClient(wallet, SEPOLIA_CONFIG.contracts.brokerAddress);

      // Step 2: Prepare RPC request
      const sessionSigner = createMessageSigner(createWalletClient({
        account: privateKeyToAccount(wallet.sessionPrivateKey),
        chain: sepolia,
        transport: http(),
      }));

      // sessionKey and sessionSigner should be the same
      if (wallet.sessionAddress !== privateKeyToAccount(wallet.sessionPrivateKey).address) {
        reject(new Error('Session key and session signer do not match'));
        return;
      }

      // Prepare channel creation parameters
      const params: CreateChannelRequestParams = {
        chain_id: SEPOLIA_CONFIG.chainId,
        token: SEPOLIA_CONFIG.contracts.tokenAddress,
        amount: amountWei, // BigInt - signer will handle serialization,
        session_key: wallet.sessionAddress
      };

      // Create message handler for RPC response
      const handleMessage = async (event: MessageEvent) => {
        try {
          const response = parseAnyRPCResponse(event.data);

          if (response.method === RPCMethod.CreateChannel) {
            ws.removeEventListener('message', handleMessage);
            try {
              // Parse RPC response to extract channel parameters and broker signature
              const parsedResponse = parseCreateChannelResponse(event.data);
              const { channel, state, serverSignature } = parsedResponse.params;

              if (!channel || !state || !serverSignature) {
                reject(new Error('Incomplete RPC response: missing channel, state, or signature'));
                return;
              }

              console.log(`  üîç ${wallet.name}: Using convertRPCToClientState (matches SDK test pattern)`);

              // Step 2: Create channel with broker's signature
              // SDK will:
              // 1. Sign the state with wallet's key
              // 2. Combine both signatures (wallet + server)
              // 3. Call custody contract's depositAndCreate() with both signatures
              const { channelId, txHash } = await nitroliteClient.depositAndCreateChannel(
                SEPOLIA_CONFIG.contracts.tokenAddress,
                amountWei,
                {
                  channel: convertRPCToClientChannel(channel),
                  unsignedInitialState: convertRPCToClientState(state, serverSignature),
                  serverSignature,                             // Passed separately
                });

              console.log(`  üì§ ${wallet.name}: Transaction submitted (${txHash.slice(0, 10)}...)`);
              console.log(`  ‚è≥ ${wallet.name}: Waiting for confirmation...`);

              // listen for channel update event
              const handleChannelUpdate = (event: MessageEvent) => {
                const response = parseChannelUpdateResponse(event.data);
                const { channelId: updatedChannelId, status } = response.params;
                if (updatedChannelId === channelId && status === RPCChannelStatus.Open) {
                  ws.removeEventListener('message', handleChannelUpdate);
                  clearTimeout(timeoutId);
                  console.log(`  ‚úÖ ${wallet.name}: Channel update received`);
                  resolve(channelId);
                }
              };
              const timeoutId = setTimeout(() => {
                ws.removeEventListener('message', handleChannelUpdate);
                reject(new Error('Timeout waiting for channel update'));
              }, 60000);
              console.log(`  ‚è≥ ${wallet.name}: Waiting for channel update...`);
            
              ws.addEventListener('message', handleChannelUpdate);

              // Wait for transaction to be mined
              await nitroliteClient.publicClient.waitForTransactionReceipt({ hash: txHash });

              
              console.log(`  ‚úÖ ${wallet.name}: Transaction confirmed`);
              console.log(`  üì° ${wallet.name}: ClearNode will detect event and populate ledger`);

              resolve(channelId);
            } catch (error) {
              console.error(`  ‚ùå ${wallet.name}: Error submitting channel transaction: ${JSON.stringify(error)}`);
              reject(new Error(`Failed to submit channel transaction: ${error instanceof Error ? error.message : 'Unknown error'}`));
            }
          } else if (response.method === RPCMethod.Error) {
            ws.removeEventListener('message', handleMessage);

            // Handle "channel already exists" error by extracting the existing channel ID
            const errorMsg = response.params?.error || '';
            const channelExistsMatch = errorMsg.match(/an open channel with broker already exists: (0x[a-fA-F0-9]+)/);

            if (channelExistsMatch) {
              const existingChannelId = channelExistsMatch[1] as Hex;
              console.log(`  ‚ÑπÔ∏è  ${wallet.name}: Channel already exists, using ${existingChannelId.slice(0, 10)}...`);
              resolve(existingChannelId);
            } else {
              console.error(`  ‚ùå ${wallet.name}: ClearNode error:`, response.params);
              reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
            }
          }
        } catch (error) {
          // Ignore parsing errors, might be other messages
        }
      };

      // Set up timeout
      const timeoutId = setTimeout(() => {
        ws.removeEventListener('message', handleMessage);
        reject(new Error('Timeout waiting for channel creation'));
      }, 60000); // 60 second timeout (includes blockchain confirmation)

      // Add message handler
      ws.addEventListener('message', handleMessage);

      // Create and send RPC request
      const message = await createCreateChannelMessage(sessionSigner, params);
      ws.send(message);
    } catch (error) {
      reject(error);
    }
  });
}



/**
 * Resize a channel via ClearNode RPC (add more funds)
 *
 * This adds funds to an existing channel and updates ClearNode's ledger tracking.
 *
 * Flow:
 * 1. Send resize request to ClearNode ‚Üí Get broker-signed resize state
 * 2. Parse response to extract resize state and serverSignature
 * 3. Create NitroliteClient and submit blockchain transaction
 * 4. Wait for transaction confirmation
 * 5. ClearNode detects event ‚Üí updates ledger balances
 */
export async function resizeChannelViaRPC(
  ws: WebSocket,
  wallet: Wallet,
  channelId: Hex,
  additionalAmount: string // Amount to ADD in USDC
): Promise<void> {
  return new Promise(async (resolve, reject) => {
    try {
      console.log(`  üí∞ ${wallet.name}: Resizing channel by ${additionalAmount} USDC...`);

      const nitroliteClient = createNitroliteClient(wallet, SEPOLIA_CONFIG.contracts.brokerAddress);
      const amountWei = parseUSDC(additionalAmount);

      const sessionSigner = createMessageSigner(createWalletClient({
        account: privateKeyToAccount(wallet.sessionPrivateKey),
        chain: sepolia,
        transport: http(),
      }));

      // Create message handler for RPC response
      const handleMessage = async (event: MessageEvent) => {
        try {
          const response = parseAnyRPCResponse(event.data);

          if (response.method === RPCMethod.ResizeChannel) {
            ws.removeEventListener('message', handleMessage);
            try {
              const parsedResponse = parseResizeChannelResponse(event.data);
              const { channelId: resizedChannelId, state, serverSignature } = parsedResponse.params;

              if (!state || !serverSignature) {
                reject(new Error('Incomplete resize response'));
                return;
              }
              // Submit resize transaction
              const txHash = await nitroliteClient.resizeChannel({
                resizeState: {
                  channelId: resizedChannelId as Hex,
                  intent: state.intent,
                  version: BigInt(state.version),
                  data: state.stateData as Hex,
                  allocations: state.allocations,
                  serverSignature,
                },
                proofStates: [],
              });

              console.log(`  üì§ ${wallet.name}: Resize tx submitted (${txHash.slice(0, 10)}...)`);

              await nitroliteClient.publicClient.waitForTransactionReceipt({ hash: txHash });

              console.log(`  ‚úÖ ${wallet.name}: Channel resized successfully`);
              resolve();
            } catch (error) {
              console.error(`  ‚ùå ${wallet.name}: Error resizing channel:`, error);
              reject(error);
            }
          } else if (response.method === RPCMethod.Error) {
            console.error(`  ‚ùå ClearNode error:`, response.params);
            ws.removeEventListener('message', handleMessage);
            reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
          }
        } catch (error) {
          // Ignore parsing errors
        }
      };

      const timeoutId = setTimeout(() => {
        ws.removeEventListener('message', handleMessage);
        reject(new Error('Timeout waiting for resize response'));
      }, 60000);

      ws.addEventListener('message', handleMessage);

      // Send resize request
      const message = await createResizeChannelMessage(sessionSigner, {
        channel_id: channelId,
        resize_amount: amountWei,
        allocate_amount: 0n,
        funds_destination: wallet.address,
      });
      ws.send(message);
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Close a channel via ClearNode RPC
 *
 * This closes a channel and returns funds to custody.
 *
 * Flow:
 * 1. Send close request to ClearNode ‚Üí Get broker-signed close state
 * 2. Parse response to extract close state and serverSignature
 * 3. Create NitroliteClient and submit blockchain transaction
 * 4. Wait for transaction confirmation
 * 5. Funds return to custody
 */
export async function closeChannelViaRPC(
  ws: WebSocket,
  wallet: Wallet,
  channelId: Hex
): Promise<void> {
  return new Promise(async (resolve, reject) => {
    try {
      console.log(`  üîí ${wallet.name}: Closing channel ${channelId.slice(0, 10)}...`);

      const nitroliteClient = createNitroliteClient(wallet, SEPOLIA_CONFIG.contracts.brokerAddress);

      const sessionSigner = createMessageSigner(createWalletClient({
        account: privateKeyToAccount(wallet.sessionPrivateKey),
        chain: sepolia,
        transport: http(),
      }));

      // Create message handler for RPC response
      const handleMessage = async (event: MessageEvent) => {
        try {
          const response = parseAnyRPCResponse(event.data);

          if (response.method === RPCMethod.CloseChannel) {
            ws.removeEventListener('message', handleMessage);
            try {
              const parsedResponse = parseCloseChannelResponse(event.data);
              const { channelId: closedChannelId, state, serverSignature } = parsedResponse.params;

              if (!state || !serverSignature) {
                reject(new Error('Incomplete close response'));
                return;
              }

              // Submit close transaction
              const txHash = await nitroliteClient.closeChannel({
                finalState: {
                  channelId: closedChannelId as Hex,
                  intent: state.intent,
                  version: BigInt(state.version),
                  data: state.stateData as Hex,
                  allocations: state.allocations,
                  serverSignature,
                },
                stateData: state.stateData as Hex,
              });

              console.log(`  üì§ ${wallet.name}: Close tx submitted (${txHash.slice(0, 10)}...)`);

              await nitroliteClient.publicClient.waitForTransactionReceipt({ hash: txHash });

              console.log(`  ‚úÖ ${wallet.name}: Channel closed successfully`);
              resolve();
            } catch (error) {
              console.error(`  ‚ùå ${wallet.name}: Error closing channel:`, error);
              reject(error);
            }
          } else if (response.method === RPCMethod.Error) {
            console.error(`  ‚ùå ClearNode error:`, response.params);
            ws.removeEventListener('message', handleMessage);
            reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
          }
        } catch (error) {
          // Ignore parsing errors
        }
      };

      const timeoutId = setTimeout(() => {
        ws.removeEventListener('message', handleMessage);
        reject(new Error('Timeout waiting for close response'));
      }, 60000);

      ws.addEventListener('message', handleMessage);

      // Send close request
      const message = await createCloseChannelMessage(
        sessionSigner,
        channelId,
        wallet.address
      );
      ws.send(message);
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Get existing channel with broker for a wallet
 *
 * Returns the channel ID if an open channel exists, null otherwise.
 *
 * Note: Since get_channels is filtered by wallet.address and RPCChannelStatus.Open,
 * it should only return the broker channel. We return the first channel found.
 */
export async function getChannelWithBroker(
  ws: WebSocket,
  wallet: Wallet,
  brokerAddress: Address
): Promise<Hex | null> {
  return new Promise(async (resolve, reject) => {
    try {
      const sessionSigner = createMessageSigner(createWalletClient({
        account: privateKeyToAccount(wallet.sessionPrivateKey),
        chain: sepolia,
        transport: http(),
      }));

      // Set up timeout
      const timeoutId = setTimeout(() => {
        ws.removeEventListener('message', handleMessage);
        reject(new Error('Timeout getting channels'));
      }, 10000);

      // Create message handler
      const handleMessage = (event: MessageEvent) => {
        try {
          const response = parseAnyRPCResponse(event.data);

          if (response.method === RPCMethod.GetChannels) {
            clearTimeout(timeoutId);
            ws.removeEventListener('message', handleMessage);

            const parsedResponse = parseGetChannelsResponse(event.data);
            const channels = parsedResponse.params.channels || [];
            console.log(`  üîç ${wallet.name}: Found ${channels.length} open channel(s)`);

            if (channels.length > 0) {
              const channel = channels[0];
              // Return first channel - should be the broker channel
              if (channel.channelId) {
                console.log(`  ‚úÖ ${wallet.name}: Using channel ${channel.channelId.slice(0, 10)}...`);
                resolve(channel.channelId);
              } else {
                console.error(`  ‚ùå ${wallet.name}: Channel missing channelId:`, channel);
                resolve(null);
              }
            } else {
              console.log(`  ‚ÑπÔ∏è  ${wallet.name}: No open channels found`);
              resolve(null);
            }
          } else if (response.method === RPCMethod.Error) {
            clearTimeout(timeoutId);
            console.error(`  ‚ùå ${wallet.name}: Error getting channels:`, response.params);
            ws.removeEventListener('message', handleMessage);
            reject(new Error(`Failed to get channels: ${JSON.stringify(response.params)}`));
          }
        } catch (error) {
          console.error(`  ‚ùå ${wallet.name}: Error in getChannelWithBroker handler:`, error);
          // Don't ignore errors - they might be important
        }
      };

      // Add message handler
      ws.addEventListener('message', handleMessage);

      // Create and send request
      const message = await createGetChannelsMessage(
        sessionSigner,
        wallet.address,
        RPCChannelStatus.Open
      );
      ws.send(message);
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Re-authenticate with allowances for app session
 *
 * Before creating an app session with non-zero allocations, each participant
 * must re-authenticate with allowances to authorize ClearNode to use their
 * ledger funds for the session.
 *
 * @param ws - Active WebSocket connection (already authenticated once)
 * @param wallet - Wallet to re-authenticate
 * @param allowances - Allowances to authorize (e.g., entry fee for game)
 */
export async function authenticateForAppSession(
  ws: WebSocket,
  wallet: Wallet,
  allowances: Array<{ asset: string; amount: string }>
): Promise<void> {
  console.log(`  üîê ${wallet.name}: Re-authenticating with allowances...`);
  await authenticateClearNode(ws, wallet, allowances);
  console.log(`  ‚úÖ ${wallet.name}: Allowances authorized`);
}

/**
 * Get off-chain ledger balances from ClearNode
 *
 * These are the balances managed by ClearNode off-chain.
 * They update in real-time as application sessions open/close.
 */
export async function getLedgerBalances(
  ws: WebSocket,
  wallet: Wallet
): Promise<Array<{ asset: string; amount: string }>> {
  return new Promise(async (resolve, reject) => {
    try {
      const signer = createMessageSigner(wallet.client);

      // Create message handler
      const handleMessage = (event: MessageEvent) => {
        try {
          const response = parseAnyRPCResponse(event.data);

          if (response.method === RPCMethod.GetLedgerBalances) {
            console.log(`  üîç ${wallet.name}: Received ledger balances`, response.params.ledgerBalances);
            ws.removeEventListener('message', handleMessage);
            // Response format: params is the array of balances
            resolve(response.params.ledgerBalances || []);
          }
        } catch (error) {
          console.error(`  üîç ${wallet.name}: Error parsing ledger balances`, error);
          // Ignore parsing errors, might be other messages
        }
      };

      // Set up timeout
      const timeoutId = setTimeout(() => {
        ws.removeEventListener('message', handleMessage);
        reject(new Error('Timeout waiting for ledger balances'));
      }, 10000);

      // Add message handler
      ws.addEventListener('message', handleMessage);

      // Create and send request
      const message = await createGetLedgerBalancesMessage(signer, wallet.address);
      ws.send(message);
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Ensure wallet has sufficient ledger balance for a game
 *
 * Checks current ledger balance and resizes channel if needed.
 * This prevents "insufficient funds" errors when creating app sessions.
 */
export async function ensureSufficientBalance(
  ws: WebSocket,
  wallet: Wallet,
  channelId: Hex,
  requiredAmount: string, // In ETH
  asset: string = 'ETH'
): Promise<void> {
  console.log(`  üîç ${wallet.name}: Checking balance...`);

  // Get current ledger balance
  const balances = await getLedgerBalances(ws, wallet);
  const balance = balances.find(b => b.asset === asset);

  if (!balance) {
    console.log(`  ‚ö†Ô∏è  ${wallet.name}: No ${asset} balance found, needs resize`);
    await resizeChannelViaRPC(ws, wallet, channelId, requiredAmount);
    return;
  }

  const requiredWei = parseUSDC(requiredAmount);
  const currentWei = BigInt(parseUnits(balance.amount, SEPOLIA_CONFIG.token.decimals));

  if (currentWei < requiredWei) {
    const deficit = requiredWei - currentWei;
    const deficitUsdc = (Number(deficit) / 10 ** SEPOLIA_CONFIG.token.decimals).toFixed(SEPOLIA_CONFIG.token.decimals);
    console.log(`  ‚ö†Ô∏è  ${wallet.name}: Insufficient balance (need ${deficitUsdc} more USDC)`);
    await resizeChannelViaRPC(ws, wallet, channelId, deficitUsdc);
  } else {
    console.log(`  ‚úÖ ${wallet.name}: Sufficient balance`);
  }
}

/**
 * Transfer funds via ClearNode ledger (off-chain)
 *
 * Transfers funds between participants' ledger balances off-chain.
 * This updates ClearNode's internal ledger without touching channels or blockchain.
 *
 * @param ws - WebSocket connection of the sender
 * @param fromWallet - Wallet sending the funds
 * @param toAddress - Address receiving the funds
 * @param amount - Amount to transfer (in USDC, e.g., "0.3")
 * @param asset - Asset identifier (e.g., "usdc")
 */
export async function transferViaLedger(
  ws: WebSocket,
  fromWallet: Wallet,
  toAddress: Address,
  amount: string,
  asset: string
): Promise<void> {
  return new Promise(async (resolve, reject) => {
    try {
      console.log(`  üí∏ ${fromWallet.name}: Transferring ${amount} ${asset.toUpperCase()} to ${toAddress.slice(0, 10)}...`);

      const sessionSigner = createMessageSigner(createWalletClient({
        account: privateKeyToAccount(fromWallet.sessionPrivateKey),
        chain: sepolia,
        transport: http(),
      }));

      // Create message handler for RPC response
      const handleMessage = async (event: MessageEvent) => {
        try {
          const response = parseAnyRPCResponse(event.data);

          if (response.method === RPCMethod.Transfer) {
            ws.removeEventListener('message', handleMessage);
            console.log(`  ‚úÖ ${fromWallet.name}: Transfer complete`);
            resolve();
          } else if (response.method === RPCMethod.Error) {
            console.error(`  ‚ùå ClearNode error:`, response.params);
            ws.removeEventListener('message', handleMessage);
            reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
          }
        } catch (error) {
          // Ignore parsing errors
        }
      };

      const timeoutId = setTimeout(() => {
        ws.removeEventListener('message', handleMessage);
        reject(new Error('Timeout waiting for transfer response'));
      }, 30000);

      ws.addEventListener('message', handleMessage);

      // Send transfer request
      const message = await createTransferMessage(sessionSigner, {
        destination: toAddress,
        allocations: [{
          amount: amount,
          asset: asset,
        }],
      });
      ws.send(message);
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Close all WebSocket connections
 */
export function disconnectAll(connections: Map<string, WebSocket>): void {
  for (const [name, ws] of connections) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.close();
    }
  }
  console.log(`   üîå Disconnected all (${connections.size} connections)`);
}
</file>

<file path="utils/contracts.ts">
export const SEPOLIA_CONFIG = {
  chainId: 11155111,
  rpcUrl: 'https://rpc.ankr.com/eth_sepolia',
  clearNodeUrl: 'ws://localhost:8000/ws', // Local ClearNode

  contracts: {
    custody: '0x019B65A265EB3363822f2752141b3dF16131b262' as const, // Latest: 2025-08-27
    adjudicator: '0x7c7ccbc98469190849BCC6c926307794fDfB11F2' as const, // Latest: 2025-08-27
    tokenAddress: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238' as const, // USDC on Sepolia
    // ClearNode broker address (Broker wallet - index 1)
    // This address must match the BROKER_PRIVATE_KEY in docker-compose.yml
    // Derived from mnemonic index 1
    brokerAddress: '0xa5819442D1A69337ca93b688994Ae27E8C58D019' as const, // UPDATE THIS after deriving from index 1
  },

  token: {
    symbol: 'USDC',
    decimals: 6,
  },

  funding: {
    // Funding wallet reserves (received from faucets)
    fundingGasReserve: '0.01',   // 0.01 ETH for Funding wallet (7 wallets √ó 0.001 + buffer)
    fundingGameReserve: '200',   // 200 USDC for Funding wallet

    // Distribution amounts per wallet
    gasAmount: '0.001',          // ETH for gas (to Broker, Server, Players) - enough for 100+ games
    gameAmount: '20',            // USDC for game (to Server and Players only)
  },

  game: {
    asset: 'USDC',
    channelDeposit: '10',     // Channel deposit: 10 USDC (~100 games worth)
    entryFee: '0.1',          // 0.1 USDC per player (testing amount)
    prizePool: '0.5',         // 5 √ó 0.1 USDC
    maxPlayers: 5,
    rounds: 3,
    commitTimeoutMs: 5000,
    revealTimeoutMs: 10000,
  },
} as const;
</file>

<file path="utils/erc20.ts">
/**
 * ERC20 Token Utilities
 *
 * Helpers for working with ERC20 tokens (USDC) in the Trivia Royale game.
 * Uses Nitrolite SDK's Erc20Service for token operations.
 */

import { Erc20Service } from '@erc7824/nitrolite';
import { parseUnits, formatUnits, type Address, type Hash } from 'viem';
import { SEPOLIA_CONFIG } from './contracts';
import type { Wallet } from './wallets';
import { createPublicRpcClient } from './wallets';

/**
 * Parse USDC amount (6 decimals) to wei
 */
export function parseUSDC(amount: string): bigint {
  return parseUnits(amount, SEPOLIA_CONFIG.token.decimals);
}

/**
 * Format USDC wei amount to human-readable string
 */
export function formatUSDC(amount: bigint): string {
  return formatUnits(amount, SEPOLIA_CONFIG.token.decimals);
}

/**
 * Create Erc20Service instance for a wallet
 */
export function createErc20Service(wallet: Wallet): Erc20Service {
  const publicClient = createPublicRpcClient();
  return new Erc20Service(publicClient, wallet.client, wallet.account);
}

/**
 * Get USDC balance for an address
 */
export async function getUSDCBalance(wallet: Wallet, address: Address): Promise<bigint> {
  const erc20Service = createErc20Service(wallet);
  return await erc20Service.getTokenBalance(SEPOLIA_CONFIG.contracts.tokenAddress, address);
}

/**
 * Ensure wallet has approved spender for the required amount
 *
 * Checks current allowance and approves if insufficient.
 * This must be called before any ERC20 deposit operation.
 */
export async function ensureAllowance(
  wallet: Wallet,
  spender: Address,
  amount: bigint
): Promise<void> {
  const erc20Service = createErc20Service(wallet);

  // Check current allowance
  const currentAllowance = await erc20Service.getTokenAllowance(
    SEPOLIA_CONFIG.contracts.tokenAddress,
    wallet.address,
    spender
  );

  // If allowance is insufficient, approve the exact amount needed
  if (currentAllowance < amount) {
    console.log(`  üîê ${wallet.name}: Approving ${formatUSDC(amount)} USDC for ${spender.slice(0, 10)}...`);

    const txHash = await erc20Service.approve(
      SEPOLIA_CONFIG.contracts.tokenAddress,
      spender,
      amount
    );

    console.log(`  ‚úÖ ${wallet.name}: Approval tx ${txHash.slice(0, 10)}... submitted`);

    // Wait for confirmation
    const publicClient = createPublicRpcClient();
    await publicClient.waitForTransactionReceipt({ hash: txHash });

    console.log(`  ‚úÖ ${wallet.name}: Approval confirmed`);
  } else {
    console.log(`  ‚úì  ${wallet.name}: Sufficient allowance already exists`);
  }
}

/**
 * Transfer USDC from one wallet to another
 *
 * Used for funding distribution (master ‚Üí players/server)
 */
export async function transferUSDC(
  fromWallet: Wallet,
  to: Address,
  amount: string
): Promise<Hash> {
  const amountWei = parseUSDC(amount);

  // Use wallet client to call ERC20 transfer function
  const hash = await fromWallet.client.writeContract({
    address: SEPOLIA_CONFIG.contracts.tokenAddress,
    abi: [
      {
        name: 'transfer',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'to', type: 'address' },
          { name: 'amount', type: 'uint256' }
        ],
        outputs: [{ name: '', type: 'bool' }]
      }
    ],
    functionName: 'transfer',
    args: [to, amountWei],
    account: fromWallet.account,
  });

  return hash;
}
</file>

<file path="utils/keyManager.ts">
/**
 * Session Keypair Management
 *
 * Generates ephemeral session keypairs for ClearNode authentication.
 * Keys are not persisted - generated fresh on each authentication.
 */

import { privateKeyToAccount } from 'viem/accounts';
import { randomBytes } from 'crypto';

export interface SessionKeypair {
  privateKey: `0x${string}`;
  address: `0x${string}`;
}

/**
 * Generate ephemeral session keypair (not persisted)
 */
export function generateSessionKeypair(): SessionKeypair {
  const privateKey = `0x${randomBytes(32).toString('hex')}` as `0x${string}`;
  const account = privateKeyToAccount(privateKey);

  return {
    privateKey,
    address: account.address,
  };
}
</file>

<file path="utils/state-tracker.ts">
/**
 * State Tracker with Storage Adapter Pattern
 *
 * Tracks all state transitions for channels to provide proof states
 * for operations like resize and close.
 *
 * Supports multiple storage backends:
 * - In-memory (default, lost on exit)
 * - Filesystem (persistent across runs)
 */

import type { Hex } from 'viem';
import type { State } from '@erc7824/nitrolite';

/**
 * Storage adapter interface for different backends
 */
export interface StorageAdapter {
  getStates(channelId: Hex): State[];
  saveStates(channelId: Hex, states: State[]): void;
  getAllChannels(): Hex[];
  clear(): void;
}

/**
 * State tracker interface - provides methods to track and query channel states
 */
export type StateTracker = {
  getChannelStates: (channelId: Hex) => State[];
  recordState: (channelId: Hex, state: State) => void;
  getProofStates: (channelId: Hex) => State[];
  getLastState: (channelId: Hex) => State | null;
  getStateByVersion: (channelId: Hex, version: bigint) => State | null;
  printStateHistory: (channelId: Hex) => void;
}

// ==================== STORAGE ADAPTERS ====================

/**
 * BigInt JSON serialization helpers for localStorage
 */
function replacerBigInt(key: string, value: any): any {
  return typeof value === 'bigint' ? value.toString() + 'n' : value;
}

function reviveBigInt(key: string, value: any): any {
  if (typeof value === 'string' && /^\d+n$/.test(value)) {
    return BigInt(value.slice(0, -1));
  }
  return value;
}

/**
 * In-memory storage adapter
 *
 * Stores states in a Map. Data is lost when process exits.
 * Best for: Scripts, tests, temporary tracking.
 */
export function createInMemoryStorage(): StorageAdapter {
  const store = new Map<Hex, State[]>();

  return {
    getStates: (channelId: Hex) => {
      return store.get(channelId) || [];
    },

    saveStates: (channelId: Hex, states: State[]) => {
      store.set(channelId, states);
    },

    getAllChannels: () => {
      return Array.from(store.keys());
    },

    clear: () => {
      store.clear();
    },
  };
}

/**
 * Filesystem storage adapter
 *
 * Persists states to filesystem. Survives restarts.
 * Best for: CLI tools, scripts, persistent tracking across runs.
 *
 * @param dirPath - Directory to store state files (default: '.state-tracker')
 */
export function createFileSystemStorage(dirPath = '.state-tracker'): StorageAdapter {
  const fs = require('fs');
  const path = require('path');

  // Ensure directory exists
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }

  return {
    getStates: (channelId: Hex) => {
      try {
        const filePath = path.join(dirPath, `${channelId}.json`);

        if (!fs.existsSync(filePath)) return [];

        const text = fs.readFileSync(filePath, 'utf-8');
        return JSON.parse(text, reviveBigInt);
      } catch (error) {
        console.error(`Failed to load states for ${channelId}:`, error);
        return [];
      }
    },

    saveStates: (channelId: Hex, states: State[]) => {
      try {
        const filePath = path.join(dirPath, `${channelId}.json`);
        const data = JSON.stringify(states, replacerBigInt, 2);
        fs.writeFileSync(filePath, data, 'utf-8');
      } catch (error) {
        console.error(`Failed to save states for ${channelId}:`, error);
      }
    },

    getAllChannels: () => {
      try {
        const files = fs.readdirSync(dirPath);
        return files
          .filter((f: string) => f.endsWith('.json'))
          .map((f: string) => f.replace('.json', '') as Hex);
      } catch (error) {
        console.error('Failed to get all channels:', error);
        return [];
      }
    },

    clear: () => {
      try {
        const files = fs.readdirSync(dirPath);
        files.forEach((f: string) => {
          const filePath = path.join(dirPath, f);
          fs.unlinkSync(filePath);
        });
      } catch (error) {
        console.error('Failed to clear storage:', error);
      }
    },
  };
}

// ==================== STATE TRACKER ====================

/**
 * Create a state tracker with the specified storage backend
 *
 * @param storage - Storage adapter (default: in-memory)
 * @returns StateTracker object with methods
 *
 * @example
 * // In-memory tracker (default)
 * const tracker = createStateTracker();
 *
 * @example
 * // Persistent tracker with filesystem
 * const tracker = createStateTracker(createFileSystemStorage());
 *
 * @example
 * // Custom directory for filesystem storage
 * const tracker = createStateTracker(createFileSystemStorage('.my-states'));
 */
export function createStateTracker(
  storage: StorageAdapter = createInMemoryStorage()
): StateTracker {
  return {
    /**
     * Get all states for a channel
     */
    getChannelStates: (channelId: Hex) => {
      return storage.getStates(channelId);
    },

    /**
     * Record a new state for a channel
     */
    recordState: (channelId: Hex, state: State) => {
      const existing = storage.getStates(channelId);

      // Check if this exact state version already exists
      const alreadyExists = existing.some(s => BigInt(s.version) === BigInt(state.version));

      if (alreadyExists) {
        console.log(`  ‚è≠Ô∏è  State v${state.version} already tracked for channel ${channelId.slice(0, 10)}... (skipping duplicate)`);
        return;
      }

      storage.saveStates(channelId, [...existing, state]);
      console.log(`  üìù Tracked state v${state.version} for channel ${channelId.slice(0, 10)}...`);
    },

    /**
     * Get all proof states for a channel
     * (Same as getChannelStates - all states can be used as proofs)
     */
    getProofStates: (channelId: Hex) => {
      return storage.getStates(channelId);
    },

    /**
     * Get the most recent state for a channel
     */
    getLastState: (channelId: Hex) => {
      const states = storage.getStates(channelId);
      const lastState = states.length > 0 ? states[states.length - 1] : null;
      if (!lastState) {
        throw new Error(`No states found for channel ${channelId.slice(0, 10)}...`);
      }
      return lastState;
    },

    /**
     * Get a specific state by version number
     */
    getStateByVersion: (channelId: Hex, version: bigint) => {
      const states = storage.getStates(channelId);
      return states.find(s => s.version === version) || null;
    },

    /**
     * Print state history for debugging
     */
    printStateHistory: (channelId: Hex) => {
      const states = storage.getStates(channelId);
      console.log(`\nüìö State History for ${channelId.slice(0, 10)}...`);
      console.log(`   Total states: ${states.length}\n`);

      states.forEach((state, idx) => {
        const intentNames = ['OPERATE', 'INITIALIZE', 'RESIZE', 'FINALIZE'];
        const intentName = intentNames[state.intent] || 'UNKNOWN';
        console.log(`   ${idx + 1}. v${state.version} - ${intentName} (${state.sigs.length} sigs)`);
      });
      console.log();
    },
  };
}
</file>

<file path="utils/wallets.ts">
import { mnemonicToAccount, generateMnemonic, english } from 'viem/accounts';
import type { Account, WalletClient, Chain, Transport, ParseAccount } from 'viem';
import { createWalletClient, createPublicClient, http } from 'viem';
import { sepolia } from 'viem/chains';
import { env } from '../env';
import { generateSessionKeypair } from './keyManager';

const WALLET_NAMES = [
  'Funding',   // index 0 - Funding source (receives from faucets, distributes to all)
  'Broker',    // index 1 - ClearNode broker (state channel counterparty)
  'Server',    // index 2 - Game server (controls game flow)
  'Alice',     // index 3 - Player
  'Bob',       // index 4 - Player
  'Charlie',   // index 5 - Player
  'Diana',     // index 6 - Player
  'Eve',       // index 7 - Player
  'Test',      // index 8 - Test wallet (clean slate for e2e tests)
  'Test2',     // index 9 - Test2 wallet (clean slate for e2e tests)
  'Test3',     // index 10 - Test3 wallet (clean slate for e2e tests)
  'Test4',     // index 11 - Test4 wallet (clean slate for e2e tests)
  'Test5',     // index 12 - Test5 wallet (clean slate for e2e tests)
  'Test6',     // index 13 - Test6 wallet (clean slate for e2e tests)
  'Test7',     // index 14 - Test7 wallet (clean slate for e2e tests)
  'Test8',     // index 15 - Test8 wallet (clean slate for e2e tests)
  'Test9',     // index 16 - Test9 wallet (clean slate for e2e tests)
  'Test10',    // index 17 - Test10 wallet (clean slate for e2e tests)
] as const;

export interface Wallet {
  name: string;
  index: number;
  account: Account;
  client: WalletClient<Transport, Chain, ParseAccount<Account>>;
  address: `0x${string}`;
  // Session keypair for ClearNode operations (signing states, RPC messages)
  sessionPrivateKey: `0x${string}`;
  sessionAddress: `0x${string}`;
}

/**
 * Wallets object with named properties for type safety and autocomplete
 */
export interface Wallets {
  funding: Wallet;
  broker: Wallet;
  server: Wallet;
  alice: Wallet;
  bob: Wallet;
  charlie: Wallet;
  diana: Wallet;
  eve: Wallet;
  test: Wallet;
  test2: Wallet;
  test3: Wallet;
  test4: Wallet;
  test5: Wallet;
  test6: Wallet;
  test7: Wallet;
  test8: Wallet;
  test9: Wallet;
  test10: Wallet;
  all: Wallet[];
  players: Wallet[];
}

/**
 * Load all wallets from MNEMONIC in .env
 */
export function loadWallets(): Wallets {
  const mnemonic = env.MNEMONIC;

  if (!mnemonic) {
    throw new Error('MNEMONIC is required - run `bun run prepare` first');
  }

  const walletArray = WALLET_NAMES.map((name, index) => {
    const account = mnemonicToAccount(mnemonic, { accountIndex: index });
    const client = createWalletClient({
      account,
      chain: sepolia,
      transport: http(),
    });

    // Generate ephemeral session keypair for ClearNode operations
    const sessionKeypair = generateSessionKeypair();

    return {
      name,
      index,
      account,
      client,
      address: account.address,
      sessionPrivateKey: sessionKeypair.privateKey,
      sessionAddress: sessionKeypair.address,
    };
  });

  // Create object with named properties
  return {
    funding: walletArray[0]!,
    broker: walletArray[1]!,
    server: walletArray[2]!,
    alice: walletArray[3]!,
    bob: walletArray[4]!,
    charlie: walletArray[5]!,
    diana: walletArray[6]!,
    eve: walletArray[7]!,
    test: walletArray[8]!,
    test2: walletArray[9]!,
    test3: walletArray[10]!,
    test4: walletArray[11]!,
    test5: walletArray[12]!,
    test6: walletArray[13]!,
    test7: walletArray[14]!,
    test8: walletArray[15]!,
    test9: walletArray[16]!,
    test10: walletArray[17]!,
    all: walletArray,
    players: [walletArray[3]!, walletArray[4]!, walletArray[5]!, walletArray[6]!, walletArray[7]!],
  };
}

/**
 * Create public client for reading blockchain
 */
export function createPublicRpcClient() {
  return createPublicClient({
    chain: sepolia,
    transport: http(),
  });
}

/**
 * Generate new mnemonic
 */
export function generateNewMnemonic(): string {
  return generateMnemonic(english);
}

/**
 * Derive address from mnemonic and index (without creating full wallet)
 */
export function deriveAddress(mnemonic: string, index: number): `0x${string}` {
  const account = mnemonicToAccount(mnemonic, { accountIndex: index });
  return account.address;
}
</file>

<file path="cashout.ts">
/**
 * Cashout Script
 *
 * Withdraws off-chain winnings to on-chain wallet.
 *
 * Flow:
 * 1. Check current balances (wallet, ledger, custody, channels)
 * 2. If open channel exists ‚Üí close it (moves funds channel ‚Üí custody)
 * 3. If custody has balance ‚Üí withdraw it (moves funds custody ‚Üí wallet)
 * 4. Verify final wallet balance
 *
 * Usage:
 *   bun run cashout alice
 *   bun run cashout bob
 */

import { loadWallets, createPublicRpcClient, type Wallet } from './utils/wallets';
import { SEPOLIA_CONFIG } from './utils/contracts';
import { connectToClearNode, authenticateClearNode } from './yellow-integration';
import {
  getLedgerBalances,
  getChannelWithBroker,
  closeChannelViaRPC
} from './utils/clearnode';
import { getUSDCBalance, formatUSDC } from './utils/erc20';
import { formatEther } from 'viem';
import { createNitroliteClient } from './utils/channels';

async function cashout(wallet: Wallet) {
  console.log(`\nüí∞ CASHOUT - ${wallet.name}\n`);

  const publicClient = createPublicRpcClient();

  // Step 1: Check all balances
  console.log('üìä Current Balances:\n');

  const walletBalance = await getUSDCBalance(wallet, wallet.address);
  console.log(`   Wallet:  ${formatUSDC(walletBalance)} USDC`);

  // Connect to ClearNode
  const ws = await connectToClearNode(SEPOLIA_CONFIG.clearNodeUrl);
  await authenticateClearNode(ws, wallet);

  const ledgerBalances = await getLedgerBalances(ws, wallet);
  const ledgerBalance = ledgerBalances.find(b => b.asset === SEPOLIA_CONFIG.game.asset);
  console.log(`   Ledger:  ${ledgerBalance?.amount || '0'} USDC (off-chain)`);

  // Check custody balance
  const nitroliteClient = createNitroliteClient(wallet, SEPOLIA_CONFIG.contracts.brokerAddress);
  const custodyBalance = await nitroliteClient.getAccountBalance(SEPOLIA_CONFIG.contracts.tokenAddress);
  console.log(`   Custody: ${formatUSDC(custodyBalance)} USDC (on-chain escrow)`);

  // Check open channels
  const channelId = await getChannelWithBroker(ws, wallet, SEPOLIA_CONFIG.contracts.brokerAddress);
  if (channelId) {
    const channelBalance = await nitroliteClient.getChannelBalance(
      channelId,
      SEPOLIA_CONFIG.contracts.tokenAddress
    );
    console.log(`   Channel: ${formatUSDC(channelBalance)} USDC (open channel ${channelId.slice(0, 10)}...)`);
  } else {
    console.log(`   Channel: No open channels`);
  }

  // Step 2: Close channel if exists
  if (channelId) {
    console.log(`üîí Closing channel ${channelId.slice(0, 10)}...`);
    console.log(`   ClearNode will calculate final balances (including off-chain winnings)\n`);

    await closeChannelViaRPC(ws, wallet, channelId);
    console.log(`‚úÖ Channel closed (funds moved to custody)\n`);

    // Wait for channel close to settle
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Re-check custody balance
    const newCustodyBalance = await nitroliteClient.getAccountBalance(SEPOLIA_CONFIG.contracts.tokenAddress);
    console.log(`   New custody balance: ${formatUSDC(newCustodyBalance)} USDC\n`);
  }

  // Step 3: Withdraw from custody
  const finalCustodyBalance = await nitroliteClient.getAccountBalance(SEPOLIA_CONFIG.contracts.tokenAddress);

  if (finalCustodyBalance > 0n) {
    console.log(`üí∏ Withdrawing ${formatUSDC(finalCustodyBalance)} USDC from custody...\n`);

    const txHash = await nitroliteClient.withdraw(
      SEPOLIA_CONFIG.contracts.tokenAddress,
      finalCustodyBalance
    );

    console.log(`   üì§ Transaction submitted: ${txHash.slice(0, 10)}...`);

    await publicClient.waitForTransactionReceipt({ hash: txHash });

    console.log(`   ‚úÖ Withdrawal confirmed\n`);
  } else {
    console.log(`‚ÑπÔ∏è  No funds in custody to withdraw\n`);
  }

  // Step 4: Verify final balance
  const finalWalletBalance = await getUSDCBalance(wallet, wallet.address);
  const finalLedgerBalances = await getLedgerBalances(ws, wallet);
  const finalLedgerBalance = finalLedgerBalances.find(b => b.asset === SEPOLIA_CONFIG.game.asset);

  console.log('üìä Final Balances:\n');
  console.log(`   Wallet:  ${formatUSDC(finalWalletBalance)} USDC (was ${formatUSDC(walletBalance)})`);
  console.log(`   Ledger:  ${finalLedgerBalance?.amount || '0'} USDC (was ${ledgerBalance?.amount || '0'})`);
  console.log(`   Custody: 0 USDC\n`);

  const profit = finalWalletBalance - walletBalance;
  if (profit > 0n) {
    console.log(`üéâ Success! Cashed out ${formatUSDC(profit)} USDC in winnings!\n`);
  } else if (profit < 0n) {
    console.log(`üìâ Net loss: ${formatUSDC(-profit)} USDC\n`);
  } else {
    console.log(`‚û°Ô∏è  No change in wallet balance\n`);
  }

  // Cleanup
  ws.close();
}

async function main() {
  const wallets = loadWallets();

  // Parse wallet name from command line (e.g., "alice", "bob")
  const walletName = process.argv[2]?.toLowerCase();

  if (!walletName) {
    console.log('‚ùå Please specify a wallet name\n');
    console.log('Usage: bun run cashout <wallet>\n');
    console.log('Available wallets:');
    console.log(`   ${wallets.players.map(w => w.name.toLowerCase()).join(', ')}\n`);
    process.exit(1);
  }

  const wallet = wallets.all.find(w => w.name.toLowerCase() === walletName);

  if (!wallet) {
    console.log(`‚ùå Wallet "${walletName}" not found\n`);
    console.log('Available wallets:');
    console.log(`   ${wallets.players.map(w => w.name.toLowerCase()).join(', ')}\n`);
    process.exit(1);
  }

  await cashout(wallet);
}

main().catch(console.error);
</file>

<file path="e2e-flow.ts">
/**
 * End-to-End Flow - Money Tracking with State History
 *
 * Demonstrates complete flow with proof state tracking:
 * 1. Channel creation (record initial state)
 * 2. Game play via app sessions (record game states)
 * 3. Check balances (ledger vs channel)
 * 4. Resize channel (allocate ledger ‚Üí channel, using proofs)
 * 5. Close channel (using proofs)
 * 6. Withdraw (custody ‚Üí wallet)
 *
 * Usage: bun run e2e-flow
 */

import { loadWallets, createPublicRpcClient, type Wallet } from './utils/wallets';
import { SEPOLIA_CONFIG } from './utils/contracts';
import { connectToClearNode, authenticateClearNode } from './yellow-integration';
import {
  getLedgerBalances,
  getChannelWithBroker,
  createChannelViaRPC,
  transferViaLedger,
} from './utils/clearnode';
import { getUSDCBalance, formatUSDC, parseUSDC } from './utils/erc20';
import { createNitroliteClient } from './utils/channels';
import {
  createStateTracker,
  createFileSystemStorage,
  type StateTracker,
} from './utils/state-tracker';
import type { Hex, Address, WalletClient } from 'viem';
import type { State } from '@erc7824/nitrolite';
import { createWalletClient, http } from 'viem';
import { sepolia } from 'viem/chains';
import { privateKeyToAccount } from 'viem/accounts';
import { createMessageSigner } from './yellow-integration';
import {
  createResizeChannelMessage,
  createCloseChannelMessage,
  parseResizeChannelResponse,
  parseCloseChannelResponse,
  parseAnyRPCResponse,
  RPCMethod,
} from '@erc7824/nitrolite';

/**
 * Step 1: Check or create channel
 */
async function ensureChannel(
  ws: WebSocket,
  wallet: Wallet,
  tracker: StateTracker
): Promise<Hex> {
  console.log('\nüîó STEP 1: Ensure Channel\n');

   let channelId = await getChannelWithBroker(
     ws,
     wallet,
     SEPOLIA_CONFIG.contracts.brokerAddress as Address
   );

  

  if (channelId) {
    console.log(`   ‚úÖ Found existing channel ${channelId.slice(0, 10)}...\n`);

    // Get current state from blockchain
    const nitroliteClient = createNitroliteClient(
      wallet,
      SEPOLIA_CONFIG.contracts.brokerAddress as Address
    );
    const channelData = await nitroliteClient.getChannelData(channelId);

    // Record the last known state
    tracker.recordState(channelId, channelData.lastValidState);
  } else {
    console.log(`   ‚è≥ Creating new channel...\n`);
    channelId = await createChannelViaRPC(
      ws,
      wallet,
      SEPOLIA_CONFIG.game.channelDeposit
    );
    console.log(`   ‚úÖ Channel created ${channelId.slice(0, 10)}...\n`);

    // Get and record initial state
    const nitroliteClient = createNitroliteClient(
      wallet,
      SEPOLIA_CONFIG.contracts.brokerAddress as Address
    );
    const channelData = await nitroliteClient.getChannelData(channelId);
    tracker.recordState(channelId, channelData.lastValidState);
  }

  return channelId;
}

/**
 * Step 2: Check all balances
 */
async function checkBalances(
  ws: WebSocket,
  wallet: Wallet,
  channelId: Hex
): Promise<{
  walletBalance: bigint;
  ledgerBalance: string;
  custodyBalance: bigint;
  channelBalance: bigint;
}> {
  console.log('\nüí∞ STEP 2: Check Balances\n');

  const publicClient = createPublicRpcClient();
  const nitroliteClient = createNitroliteClient(
    wallet,
    SEPOLIA_CONFIG.contracts.brokerAddress as Address
  );

  const walletBalance = await getUSDCBalance(wallet, wallet.address);
  const ledgerBalances = await getLedgerBalances(ws, wallet);
  const ledgerBalance =
    ledgerBalances.find((b) => b.asset === SEPOLIA_CONFIG.game.asset)?.amount ||
    '0';
  const custodyBalance = await nitroliteClient.getAccountBalance(
    SEPOLIA_CONFIG.contracts.tokenAddress as Address
  );
  const channelBalance = await nitroliteClient.getChannelBalance(
    channelId,
    SEPOLIA_CONFIG.contracts.tokenAddress as Address
  );

  console.log(`   Wallet:  ${formatUSDC(walletBalance)} USDC (on-chain)`);
  console.log(`   Ledger:  ${ledgerBalance} USDC (off-chain with ClearNode)`);
  console.log(`   Custody: ${formatUSDC(custodyBalance)} USDC (on-chain escrow)`);
  console.log(`   Channel: ${formatUSDC(channelBalance)} USDC (locked in channel)\n`);

  return { walletBalance, ledgerBalance, custodyBalance, channelBalance };
}

/**
 * Step 2.5: Simulate Alice sending money to another wallet (via ledger transfer)
 */
async function simulateTransfer(
  aliceWs: WebSocket,
  alice: Wallet,
  toAddress: Address
): Promise<void> {
  console.log('\nüí∏ STEP 2.5: Simulate Transfer (Alice ‚Üí Test8)\n');

  await transferViaLedger(
    aliceWs,
    alice,
    toAddress,
    '0.3',  // Alice sends 0.3 USDC
    SEPOLIA_CONFIG.game.asset
  );

  console.log(`   ‚úÖ Alice sent 0.3 USDC to ${toAddress.slice(0, 10)}... (ledger balance updated)\n`);
}

/**
 * Step 3: Resize channel if needed (allocate ledger ‚Üí channel)
 */
async function resizeIfNeeded(
  ws: WebSocket,
  wallet: Wallet,
  channelId: Hex,
  ledgerBalance: string,
  channelBalance: bigint,
  tracker: StateTracker
): Promise<void> {
  const ledgerBalanceWei = parseUSDC(ledgerBalance);
  const extraFunds = ledgerBalanceWei - channelBalance;

  if (extraFunds <= 0n) {
    console.log('\nüìè STEP 3: Resize Channel - SKIPPED (no extra funds)\n');
    return;
  }

  console.log('\nüìè STEP 3: Resize Channel\n');

  const extraUSDC = formatUSDC(extraFunds);
  console.log(`   Need to allocate ${extraUSDC} USDC from ledger to channel\n`);

  // Get proof states
  const proofStates = tracker.getProofStates(channelId);
  console.log(`   üìö Using ${proofStates.length} proof state(s)\n`);

  const nitroliteClient = createNitroliteClient(
    wallet,
    SEPOLIA_CONFIG.contracts.brokerAddress as Address
  );

  // Request resize from ClearNode
  const sessionSigner = createMessageSigner(
    createWalletClient({
      account: privateKeyToAccount(wallet.sessionPrivateKey),
      chain: sepolia,
      transport: http(),
    })
  );

  const resizeMessage = await createResizeChannelMessage(sessionSigner, {
    channel_id: channelId,
    resize_amount: -extraFunds,
    allocate_amount: -extraFunds,
    funds_destination: wallet.address,
  });

  const resizeResponse = await new Promise<any>((resolve, reject) => {
    const handleMessage = (event: MessageEvent) => {
      try {
        const response = parseAnyRPCResponse(event.data);
        if (response.method === RPCMethod.ResizeChannel) {
          ws.removeEventListener('message', handleMessage);
          resolve(parseResizeChannelResponse(event.data));
        } else if (response.method === RPCMethod.Error) {
          ws.removeEventListener('message', handleMessage);
          reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
        }
      } catch (err) {
        // Ignore parsing errors
      }
    };

    ws.addEventListener('message', handleMessage);
    ws.send(resizeMessage);

    setTimeout(() => {
      ws.removeEventListener('message', handleMessage);
      reject(new Error('Timeout waiting for resize response'));
    }, 30000);
  });

  console.log(`   ‚úÖ Got resize state from ClearNode (v${resizeResponse.params.state.version})\n`);

  console.log({
    msg: 'resizeResponse',
    proofStates,

  });

  // Submit resize transaction with proof states
  const txHash = await nitroliteClient.resizeChannel({
    resizeState: {
      channelId: resizeResponse.params.channelId as Hex,
      intent: resizeResponse.params.state.intent,
      version: BigInt(resizeResponse.params.state.version),
      data: resizeResponse.params.state.stateData as Hex,
      allocations: resizeResponse.params.state.allocations,
      serverSignature: resizeResponse.params.serverSignature,
    },
    proofStates,
  });

  console.log(`   üì§ Resize tx submitted: ${txHash.slice(0, 10)}...`);

  const publicClient = createPublicRpcClient();
  await publicClient.waitForTransactionReceipt({ hash: txHash });

  console.log(`   ‚úÖ Resize confirmed!\n`);

  // Record the new state
  const newChannelData = await nitroliteClient.getChannelData(channelId);
  tracker.recordState(channelId, newChannelData.lastValidState);
}

/**
 * Step 4: Close channel
 */
async function closeChannel(
  ws: WebSocket,
  wallet: Wallet,
  channelId: Hex,
  tracker: StateTracker
): Promise<void> {
  console.log('\nüîí STEP 4: Close Channel\n');

  // Request close from ClearNode
  const sessionSigner = createMessageSigner(
    createWalletClient({
      account: privateKeyToAccount(wallet.sessionPrivateKey),
      chain: sepolia,
      transport: http(),
    })
  );

  const closeMessage = await createCloseChannelMessage(
    sessionSigner,
    channelId,
    wallet.address
  );

  const closeResponse = await new Promise<any>((resolve, reject) => {
    const handleMessage = (event: MessageEvent) => {
      try {
        const response = parseAnyRPCResponse(event.data);
        if (response.method === RPCMethod.CloseChannel) {
          ws.removeEventListener('message', handleMessage);
          resolve(parseCloseChannelResponse(event.data));
        } else if (response.method === RPCMethod.Error) {
          ws.removeEventListener('message', handleMessage);
          reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
        }
      } catch (err) {
        // Ignore parsing errors
      }
    };

    ws.addEventListener('message', handleMessage);
    ws.send(closeMessage);

    setTimeout(() => {
      ws.removeEventListener('message', handleMessage);
      reject(new Error('Timeout waiting for close response'));
    }, 30000);
  });

  console.log(`   ‚úÖ Got close state from ClearNode (v${closeResponse.params.state.version})\n`);

  // Submit close transaction (no proof states needed for close!)
  const nitroliteClient = createNitroliteClient(
    wallet,
    SEPOLIA_CONFIG.contracts.brokerAddress as Address
  );

  const txHash = await nitroliteClient.closeChannel({
    finalState: {
      channelId: closeResponse.params.channelId as Hex,
      intent: closeResponse.params.state.intent,
      version: BigInt(closeResponse.params.state.version),
      data: closeResponse.params.state.stateData as Hex,
      allocations: closeResponse.params.state.allocations,
      serverSignature: closeResponse.params.serverSignature,
    },
    stateData: closeResponse.params.state.stateData as Hex,
  });

  console.log(`   üì§ Close tx submitted: ${txHash.slice(0, 10)}...`);

  const publicClient = createPublicRpcClient();
  await publicClient.waitForTransactionReceipt({ hash: txHash });

  console.log(`   ‚úÖ Channel closed!\n`);
}

/**
 * Step 5: Withdraw from custody
 */
async function withdraw(wallet: Wallet): Promise<void> {
  console.log('\nüí∏ STEP 5: Withdraw from Custody\n');

  const nitroliteClient = createNitroliteClient(
    wallet,
    SEPOLIA_CONFIG.contracts.brokerAddress as Address
  );

  const custodyBalance = await nitroliteClient.getAccountBalance(
    SEPOLIA_CONFIG.contracts.tokenAddress as Address
  );

  if (custodyBalance === 0n) {
    console.log(`   ‚ÑπÔ∏è  No funds in custody to withdraw\n`);
    return;
  }

  console.log(`   Withdrawing ${formatUSDC(custodyBalance)} USDC...\n`);

  const txHash = await nitroliteClient.withdrawal(
    SEPOLIA_CONFIG.contracts.tokenAddress as Address,
    custodyBalance
  );

  console.log(`   üì§ Withdraw tx submitted: ${txHash.slice(0, 10)}...`);

  const publicClient = createPublicRpcClient();
  await publicClient.waitForTransactionReceipt({ hash: txHash });

  console.log(`   ‚úÖ Withdrawal complete!\n`);
}

/**
 * Main flow
 */
async function main() {
  console.log('\nüéÆ TRIVIA ROYALE - End-to-End Flow\n');

  const wallets = loadWallets();
  const test10 = wallets.test10;  // Using clean test10 wallet!
  const alice = wallets.alice;  // Alice will send money to test10

  console.log(`Using test10 wallet: ${test10.address}`);
  console.log(`Using Alice wallet: ${alice.address}\n`);

  // Create state tracker with filesystem storage (persists across runs)
  const tracker = createStateTracker(createFileSystemStorage('.state-tracker'));

  // Connect BOTH test10 and Alice to ClearNode
  console.log('üîó Connecting to ClearNode...\n');
  const test10Ws = await connectToClearNode(SEPOLIA_CONFIG.clearNodeUrl);
  await authenticateClearNode(test10Ws, test10);

  const aliceWs = await connectToClearNode(SEPOLIA_CONFIG.clearNodeUrl);
  await authenticateClearNode(aliceWs, alice);

  // withdraw 0.3 USDC from test10
  await withdraw(test10);

  return

  try {
    // Step 1: Ensure channel exists
    const channelId = await ensureChannel(test10Ws, test10, tracker);

    // Step 2: Check initial balances
    const initialBalances = await checkBalances(test10Ws, test10, channelId);

    // Step 2.5: Simulate Alice ‚Üí test10 transfer
    await simulateTransfer(aliceWs, alice, test10.address);

    // Check balances after transfer (ledger should show +0.3 USDC)
    const afterTransfer = await checkBalances(test10Ws, test10, channelId);

    // Step 3: Resize if needed (allocate extra ledger funds ‚Üí channel)
    await resizeIfNeeded(
      test10Ws,
      test10,
      channelId,
      afterTransfer.ledgerBalance,
      afterTransfer.channelBalance,
      tracker
    );

    // Print state history
    tracker.printStateHistory(channelId);

    // Step 4: Close channel
    await closeChannel(test10Ws, test10, channelId, tracker);

    // Step 5: Withdraw
    await withdraw(test10);

    // Final balances
    const finalWalletBalance = await getUSDCBalance(test10, test10.address);
    console.log(`\nüéâ COMPLETE!\n`);
    console.log(`   Initial wallet: ${formatUSDC(initialBalances.walletBalance)} USDC`);
    console.log(`   Final wallet:   ${formatUSDC(finalWalletBalance)} USDC`);
    console.log(`   Profit:         ${formatUSDC(finalWalletBalance - initialBalances.walletBalance)} USDC\n`);
  } finally {
    test10Ws.close();
    aliceWs.close();
  }
}

main().catch(console.error);
</file>

<file path="env.ts">
import z from "zod";

export const envSchema = z.object({
  MNEMONIC: z.string({ error: () => `MNEMONIC is required - run \`bun run prepare\` first` }).optional(),
  DEBUG: z.string().optional(),
});

export const env = envSchema.parse(Bun.env);

/**
 * Debug logging flag
 * Set DEBUG=true in .env to enable verbose logging
 */
export const DEBUG = env.DEBUG === "true";
</file>

<file path="fund.ts">
/**
 * Fund Distribution Script
 *
 * Distributes dual currencies from Funding wallet:
 * 1. ETH for gas fees (to Broker, Server, and all Players)
 * 2. USDC for game play (to Server and Players only)
 */

import {
  loadWallets,
  createPublicRpcClient,
  type Wallet,
} from './utils/wallets';
import { SEPOLIA_CONFIG } from './utils/contracts';
import { transferUSDC, getUSDCBalance, formatUSDC, parseUSDC } from './utils/erc20';
import { formatEther, parseEther } from 'viem';

/**
 * Send ETH from funding wallet to target wallet (for gas)
 */
async function sendETH(
  funding: Wallet,
  target: Wallet,
  amount: string
): Promise<void> {
  const amountWei = parseEther(amount);

  const hash = await funding.client.sendTransaction({
    account: funding.account,
    to: target.address,
    value: amountWei,
  });

  console.log(`   ‚úÖ ${target.name}: Sent ${amount} ETH (gas) (tx: ${hash.slice(0, 10)}...)`);
}

/**
 * Send USDC from funding wallet to target wallet (for game)
 */
async function sendUSDC(
  funding: Wallet,
  target: Wallet,
  amount: string
): Promise<void> {
  const hash = await transferUSDC(funding, target.address, amount);

  console.log(`   ‚úÖ ${target.name}: Sent ${amount} USDC (game) (tx: ${hash.slice(0, 10)}...)`);
}

/**
 * Filter wallets by names (case-insensitive)
 */
function filterWalletsByNames(
  wallets: Wallet[],
  names: string[]
): { matched: Wallet[]; invalid: string[] } {
  const matched: Wallet[] = [];
  const invalid: string[] = [];

  for (const name of names) {
    const wallet = wallets.find(w => w.name.toLowerCase() === name.toLowerCase());
    if (wallet) {
      matched.push(wallet);
    } else {
      invalid.push(name);
    }
  }

  return { matched, invalid };
}

/**
 * Main distribution function - dual currency
 */
async function distributeFunds(
  funding: Wallet,
  gasRecipients: Wallet[],
  gameRecipients: Wallet[]
): Promise<void> {
  const gasAmount = SEPOLIA_CONFIG.funding.gasAmount;
  const gameAmount = SEPOLIA_CONFIG.funding.gameAmount;

  console.log(`üí∏ Phase 1: Distributing ${gasAmount} ETH (gas) to ${gasRecipients.length} wallets...\n`);

  for (const recipient of gasRecipients) {
    await sendETH(funding, recipient, gasAmount);
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  console.log(`\nüí∏ Phase 2: Distributing ${gameAmount} USDC (game) to ${gameRecipients.length} wallets...\n`);

  for (const recipient of gameRecipients) {
    await sendUSDC(funding, recipient, gameAmount);
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  console.log('\n‚úÖ All distributions complete!');
}

async function main() {
  console.log('\nüéÆ TRIVIA ROYALE - Fund Distribution\n');

  const wallets = loadWallets();
  const funding = wallets.funding;
  const broker = wallets.broker;
  const players = wallets.players;
  const server = wallets.server;
  const test = wallets.test;
  const test2 = wallets.test2;
  const test3 = wallets.test3;
  const test4 = wallets.test4;
  const test5 = wallets.test5;
  const test6 = wallets.test6;
  const test7 = wallets.test7;
  const test8 = wallets.test8;
  const test9 = wallets.test9;
  const test10 = wallets.test10;
  const publicClient = createPublicRpcClient();

  // Check funding wallet balances
  const fundingEthBalance = await publicClient.getBalance({ address: funding.address });
  const fundingUsdcBalance = await getUSDCBalance(funding, funding.address);

  console.log('üí∞ Funding Wallet:\n');
  console.log(`   Address: ${funding.address}`);
  console.log(`   ETH Balance:  ${formatEther(fundingEthBalance)}`);
  console.log(`   USDC Balance: ${formatUSDC(fundingUsdcBalance)}\n`);

  // Parse command-line arguments for selective funding
  const walletNames = process.argv.slice(2);

  // All possible recipients (before filtering)
  // Gas recipients: Broker + Server + 5 Players + Test + Test2 + Test3 + Test4 + Test5 + Test6 + Test7 + Test8 + Test9 + Test10 = 17 wallets
  let gasRecipients = [broker, server, ...players, test, test2, test3, test4, test5, test6, test7, test8, test9, test10];

  // Game recipients: Server + 5 Players + Test + Test2 + Test3 + Test4 + Test5 + Test6 + Test7 + Test8 + Test9 + Test10 = 16 wallets (Broker doesn't need USDC)
  let gameRecipients = [server, ...players, test, test2, test3, test4, test5, test6, test7, test8, test9, test10];

  // Apply filter if wallet names provided
  if (walletNames.length > 0) {
    const allPossibleRecipients = [...gasRecipients];
    const { matched, invalid } = filterWalletsByNames(allPossibleRecipients, walletNames);

    if (invalid.length > 0) {
      console.log(`‚ùå Invalid wallet name(s): ${invalid.join(', ')}\n`);
      console.log('Available wallets:');
      console.log(`   ${allPossibleRecipients.map(w => w.name).join(', ')}\n`);
      return;
    }

    gasRecipients = matched;
    // Game recipients exclude Broker even if specified
    gameRecipients = matched.filter(w => w.name !== 'Broker');

    console.log(`üìã Funding ${matched.length} selected wallet(s):`);
    console.log(`   ${matched.map(w => w.name).join(', ')}\n`);
  } else {
    console.log(`üìã Funding all ${gasRecipients.length} wallets\n`);
  }

  // Calculate required amounts
  const requiredEth = parseEther(SEPOLIA_CONFIG.funding.gasAmount) * BigInt(gasRecipients.length);
  const requiredUsdc = parseUSDC(SEPOLIA_CONFIG.funding.gameAmount) * BigInt(gameRecipients.length);

  // Check if funding wallet has enough
  if (fundingEthBalance < requiredEth) {
    console.log('‚ùå Insufficient ETH in funding wallet!\n');
    console.log(`   Required: ${formatEther(requiredEth)} ETH`);
    console.log(`   Available: ${formatEther(fundingEthBalance)} ETH\n`);
    console.log('üìã Fund funding wallet first:');
    console.log('   bun run prepare\n');
    return;
  }

  if (fundingUsdcBalance < requiredUsdc) {
    console.log('‚ùå Insufficient USDC in funding wallet!\n');
    console.log(`   Required: ${formatUSDC(requiredUsdc)} USDC`);
    console.log(`   Available: ${formatUSDC(fundingUsdcBalance)} USDC\n`);
    console.log('üìã Fund funding wallet first:');
    console.log('   bun run prepare\n');
    return;
  }

  // Distribute to all wallets
  await distributeFunds(funding, gasRecipients, gameRecipients);

  // Show final balances
  console.log('\nüí∞ Final Balances:\n');

  for (const wallet of [...gasRecipients]) {
    const ethBalance = await publicClient.getBalance({ address: wallet.address });
    const usdcBalance = await getUSDCBalance(funding, wallet.address);
    console.log(`   ${wallet.name.padEnd(8)}: ${formatEther(ethBalance).padStart(10)} ETH | ${formatUSDC(usdcBalance).padStart(10)} USDC`);
  }

  const finalFundingEth = await publicClient.getBalance({ address: funding.address });
  const finalFundingUsdc = await getUSDCBalance(funding, funding.address);
  console.log(`   ${funding.name.padEnd(8)}: ${formatEther(finalFundingEth).padStart(10)} ETH | ${formatUSDC(finalFundingUsdc).padStart(10)} USDC (remaining)\n`);

  console.log('üìã Next Steps:');
  console.log('   1. Run: bun run status');
  console.log('   2. Run: bun run play\n');
}

main().catch(console.error);
</file>

<file path="play.ts">
/**
 * Trivia Royale - Full Yellow SDK Integration Demo
 *
 * This demo showcases Yellow Network SDK's 3-layer architecture for building
 * fast, low-cost, multi-party blockchain games.
 *
 * ========================================
 * WHAT YELLOW SDK DOES (Infrastructure):
 * ========================================
 *
 * Layer 1: STATE CHANNELS (On-Chain Escrow)
 * ------------------------------------------
 * - Creates 2-party payment channels between each player and server
 * - Locks funds on-chain in custody contract (0.0001 ETH per player)
 * - Enables off-chain state updates without gas fees
 * - Secure: Funds escrowed on-chain, can't be stolen
 * - Used in: Line 387 via `setupChannelsViaRPC()`
 *
 * Layer 2: CLEARNODE (Off-Chain Messaging)
 * -----------------------------------------
 * - WebSocket server for real-time pub/sub messaging
 * - URL: wss://testnet-clearnode.nitrolite.org
 * - Authentication: Challenge-response with wallet signatures
 * - Fast: Messages propagate instantly (no block confirmations)
 * - Free: Zero gas fees for messages
 * - Used in: Line 382 via `connectAllParticipants()`
 *
 * Layer 3: APPLICATION SESSIONS (Multi-Party Coordination)
 * ---------------------------------------------------------
 * - Creates N-party coordination layer (6 participants: 5 players + 1 server)
 * - Server controls game flow (weights: [0,0,0,0,0,100])
 * - Routes messages between all participants via ClearNode
 * - Tracks allocations (entry fees, prize distributions)
 * - Used in: Line 390+ via game clients
 *
 * ========================================
 * WHAT'S GAME LOGIC (Not Yellow SDK):
 * ========================================
 *
 * - Trivia questions and answers (QUESTIONS array)
 * - Commit-reveal protocol (createCommitment, verifyCommitment)
 * - Winner determination (fastest correct answer)
 * - Prize calculation (50% / 30% / 20% split)
 *
 * Yellow SDK provides the INFRASTRUCTURE (escrow, messaging, coordination).
 * Game logic uses that infrastructure to build a fair, fast trivia game.
 *
 * ========================================
 * THE VALUE PROPOSITION:
 * ========================================
 *
 * WITHOUT Yellow SDK:
 * - Every game action = on-chain transaction (slow, expensive)
 * - Example: 3 rounds √ó 5 players √ó 2 txs (commit + reveal) = 30 transactions
 * - Cost: ~$30 in gas fees (at 10 gwei)
 * - Speed: 12 seconds per block √ó 30 = 6 minutes total
 *
 * WITH Yellow SDK:
 * - Only 2 on-chain txs: channel creation + settlement
 * - All game messages via ClearNode (off-chain, instant, free)
 * - Cost: ~$2 in gas fees (90% cheaper)
 * - Speed: ~30 seconds total (12√ó faster)
 *
 * ========================================
 * COMPLETE FLOW:
 * ========================================
 *
 * 1. Connect to ClearNode (off-chain WebSocket) - Line 382
 * 2. Create channels via RPC (on-chain + ledger tracking) - Line 387
 * 3. Create application session (6 participants) - Line 390+
 * 4. Play trivia game via ClearNode messages - Line 390+
 * 5. Close session and disconnect - Line 438+
 */

import { keccak256, encodePacked, type Hex, type Address, parseUnits } from 'viem';
import {
  loadWallets,
  type Wallet,
} from './utils/wallets';
import { SEPOLIA_CONFIG } from './utils/contracts';
import { parseUSDC, formatUSDC } from './utils/erc20';
import {
  connectAllParticipants,
  disconnectAll,
  createChannelViaRPC,
  getChannelWithBroker,
  authenticateForAppSession,
  ensureSufficientBalance,
  getLedgerBalances,
} from './utils/clearnode';
import { createMessageSigner, createGameSessionWithMultiSig } from './yellow-integration';
import type { MessageSigner, NitroliteClient } from '@erc7824/nitrolite';
import { createServerClient } from './game/ServerGameClient';
import { createPlayerClient } from './game/PlayerGameClient';
import type { GameResults, PrizeDistribution, PlayerMockConfig } from './game/types';

// ==================== GAME DATA ====================

const QUESTIONS = [
  { question: 'What year was Bitcoin launched?', answer: '2009' },
  { question: 'What is the native token of Ethereum?', answer: 'ETH' },
  { question: 'Who created Bitcoin?', answer: 'Satoshi Nakamoto' },
];

// Mock configurations for each player (demo mode)
const PLAYER_MOCK_CONFIGS: Record<string, PlayerMockConfig> = {
  Alice: {
    answers: [
      { answer: '2009', delay: 1200 },                 // Round 1: ‚úì WINNER
      { answer: 'Ether', delay: 1500 },                // Round 2: ‚úó
      { answer: 'Satoshi', delay: 2000 },              // Round 3: ‚úó
    ],
  },
  Bob: {
    answers: [
      { answer: '2008', delay: 800 },                  // Round 1: ‚úó (fast but wrong)
      { answer: 'ETH', delay: 1800 },                  // Round 2: ‚úì
      { answer: 'Satoshi Nakamoto', delay: 1000 },     // Round 3: ‚úì WINNER
    ],
  },
  Charlie: {
    answers: [
      { answer: '2009', delay: 1500 },                 // Round 1: ‚úì
      { answer: 'ETH', delay: 900 },                   // Round 2: ‚úì WINNER (fastest)
      { answer: 'Satoshi Nakamoto', delay: 1600 },     // Round 3: ‚úì
    ],
  },
  Diana: {
    answers: [
      { answer: '2009', delay: 2000 },                 // Round 1: ‚úì
      { answer: 'Ethereum', delay: 2200 },             // Round 2: ‚úó
      { answer: 'Satoshi Nakamoto', delay: 2500 },     // Round 3: ‚úì
    ],
  },
  Eve: {
    answers: [
      { answer: '2010', delay: 2500 },                 // Round 1: ‚úó
      { answer: 'ETH', delay: 2800 },                  // Round 2: ‚úì
      { answer: 'Hal Finney', delay: 3000 },           // Round 3: ‚úó
    ],
  },
};

// ==================== HELPER FUNCTIONS ====================

function calculatePrizes(results: [string, number][]): PrizeDistribution[] {
  const entryFee = parseFloat(SEPOLIA_CONFIG.game.entryFee);
  const totalPool = entryFee * 5;

  const distribution = [
    { pct: 0.50, prize: totalPool * 0.50 },
    { pct: 0.30, prize: totalPool * 0.30 },
    { pct: 0.20, prize: totalPool * 0.20 },
  ];

  return results.map(([name, wins], index) => {
    const dist = distribution[index] || { prize: 0 };
    const finalPrize = dist.prize;
    const change = finalPrize - entryFee;

    return {
      name,
      wins,
      prize: finalPrize.toFixed(6),
      change: change.toFixed(6),
    };
  });
}

// ==================== GAME FLOW ====================

/**
 * Create channels via ClearNode RPC
 *
 * This creates channels that ClearNode knows about and tracks in its database.
 * Requires active WebSocket connections.
 */
async function setupChannelsViaRPC(
  players: Wallet[],
  connections: Map<string, WebSocket>,
): Promise<Map<string, string>> {
  console.log('2. Creating channels via ClearNode (on-chain + ledger tracking)...\n');

  const channelIds = new Map<string, string>(); // Map of player name -> channel ID

  for (const player of players) {
    const ws = connections.get(player.name);
    if (!ws) {
      throw new Error(`No WebSocket connection for ${player.name}`);
    }

    try {
      // Check if channel already exists
      const existingChannel = await getChannelWithBroker(ws, player, SEPOLIA_CONFIG.contracts.brokerAddress);

      let channelId: string;
      if (existingChannel) {
        // Reuse existing channel
        channelId = existingChannel;
        console.log(`  ‚úÖ ${player.name}: Reusing channel ${channelId.slice(0, 10)}...`);
      } else {
        // Create new channel with enough funds for multiple games
        console.log(`  ‚è≥ ${player.name}: Creating channel...`);
        channelId = await createChannelViaRPC(ws, player, SEPOLIA_CONFIG.game.channelDeposit);
        console.log(`  ‚úÖ ${player.name}: Channel ${channelId.slice(0, 10)}... created`);
      }

      channelIds.set(player.name, channelId);
    } catch (error) {
      console.log(`  ‚ùå ${player.name}: Failed to get/create channel`);
      throw error;
    }
  }

  console.log(`   ‚úÖ All ${channelIds.size} channels created\n`);
  return channelIds;
}

async function playGame(
  players: Wallet[],
  server: Wallet,
  connections: Map<string, WebSocket>,
  participants: Address[],
  initialAllocations: Array<{ participant: Address; asset: string; amount: string }>,
  channelIds: Map<string, string>
): Promise<{ results: GameResults; sessionId: Hex; gameClients: { server: any; players: any[] } }> {
  console.log('üé≤ SETTING UP GAME\n');

  const results: GameResults = { wins: new Map() };
  players.forEach(p => results.wins.set(p.name, 0));

  // Check and ensure sufficient balance for each player
  console.log('  üí∞ Checking balances...\n');
  for (const player of players) {
    const playerWs = connections.get(player.name);
    if (!playerWs) throw new Error(`Player ${player.name} not connected`);

    const allocation = initialAllocations.find(a => a.participant === player.address);
    if (!allocation || allocation.amount === '0') continue;

    const channelId = channelIds.get(player.name);
    if (!channelId) throw new Error(`No channel ID for ${player.name}`);

    await ensureSufficientBalance(
      playerWs,
      player,
      channelId as Hex,
      allocation.amount,
      SEPOLIA_CONFIG.game.asset
    );
  }
  console.log('  ‚úÖ All balances sufficient\n');

  // Re-authenticate players with allowances for app session funding
  console.log('  üîê Re-authenticating players with allowances...\n');
  for (const player of players) {
    const playerWs = connections.get(player.name);
    if (!playerWs) throw new Error(`Player ${player.name} not connected`);

    // Find this player's allocation amount
    const allocation = initialAllocations.find(a => a.participant === player.address);
    if (!allocation || allocation.amount === '0') {
      console.log(`  ‚è≠Ô∏è  ${player.name}: Skipping (no allocation)`);
      continue;
    }

    // Re-authenticate with allowances
    // Convert USDC to smallest unit for allowances (must be whole number string)
    const amountWei = parseUSDC(allocation.amount).toString();
    await authenticateForAppSession(playerWs, player, [
      {
        asset: allocation.asset,
        amount: amountWei,
      }
    ]);
  }
  console.log('  ‚úÖ All players authorized\n');

  // Create server client
  const serverWs = connections.get(server.name);
  if (!serverWs) throw new Error('Server not connected');

  const serverSigner = createMessageSigner(server.client);
  const serverClient = createServerClient({
    ws: serverWs,
    signer: serverSigner,
    participants,
    serverAddress: server.address,
  });

  // Create player clients
  const playerClients = players.map(player => {
    const playerWs = connections.get(player.name);
    if (!playerWs) throw new Error(`Player ${player.name} not connected`);

    const playerSigner = createMessageSigner(player.client);
    const mockConfig = PLAYER_MOCK_CONFIGS[player.name];

    return createPlayerClient({
      ws: playerWs,
      signer: playerSigner,
      wallet: player,
      mockConfig,
    });
  });

  // Start all clients (BEFORE creating session!)
  await serverClient.start();
  await Promise.all(playerClients.map(client => client.start()));

  console.log('  ‚úÖ All game clients ready\n');

  // NOW create the session with multi-signature (clients are listening)
  console.log('  üéÆ Creating game session with multi-signature...\n');

  // Collect player signers for multi-sig
  const playerSigners = new Map<Address, MessageSigner>();
  for (const player of players) {
    const allocation = initialAllocations.find(a => a.participant === player.address);
    if (allocation && allocation.amount !== '0') {
      playerSigners.set(player.address, createMessageSigner(player.client));
    }
  }

  // Create session with multi-signature
  const session = await createGameSessionWithMultiSig(
    serverWs,
    serverSigner,
    playerSigners,
    participants,
    initialAllocations,
    server.address,
    'NitroRPC/0.4'
  );
  const sessionId = session.sessionId;
  console.log(`  ‚úÖ Session created: ${sessionId}\n`);

  console.log('üé≤ PLAYING TRIVIA GAME\n');

  // Play rounds
  for (let roundNum = 0; roundNum < SEPOLIA_CONFIG.game.rounds; roundNum++) {
    const question = QUESTIONS[roundNum];
    if (!question) break;

    console.log('='.repeat(60));
    console.log(`ROUND ${roundNum + 1}: ${question.question}`);
    console.log('='.repeat(60) + '\n');

    // COMMIT PHASE
    console.log('üìù COMMIT PHASE (5 seconds)\n');

    const questionSentAt = await serverClient.broadcastQuestion(
      sessionId,
      question.question,
      roundNum + 1,
      SEPOLIA_CONFIG.game.commitTimeoutMs
    );

    // Collect commits (players auto-respond via their clients)
    const commits = await serverClient.collectCommits(
      questionSentAt,
      SEPOLIA_CONFIG.game.commitTimeoutMs
    );

    console.log(`\n   üì• Collected ${commits.size} commits\n`);

    // REVEAL PHASE
    console.log('üîì REVEAL PHASE\n');

    await serverClient.requestReveals(sessionId, roundNum + 1);

    const reveals = await serverClient.collectReveals(
      questionSentAt,
      2000 // Give 2 seconds for reveals
    );

    // Display reveals
    for (const [address, reveal] of reveals) {
      const player = players.find(p => p.address === address);
      const icon = reveal.isCorrect ? '‚úì' : '‚úó';
      const validIcon = reveal.isValid ? '' : '‚ö†Ô∏è ';
      console.log(`   ${validIcon}${icon} ${player?.name}: "${reveal.answer}"`);
    }

    // Determine winner
    const winner = serverClient.determineWinner(reveals, question.answer);

    if (winner) {
      const winnerPlayer = players.find(p => p.address === winner.playerAddress);
      if (winnerPlayer) {
        console.log(`\nüèÜ WINNER: ${winnerPlayer.name} (${winner.responseTime}ms)\n`);
        results.wins.set(winnerPlayer.name, (results.wins.get(winnerPlayer.name) || 0) + 1);
      }
    } else {
      console.log('\nüíÄ No winners\n');
    }

    // Broadcast result
    await serverClient.broadcastResult(
      sessionId,
      roundNum + 1,
      winner,
      question.answer
    );
  }

  // Return results, session ID, and clients (for cleanup)
  return {
    results,
    sessionId,
    gameClients: {
      server: serverClient,
      players: playerClients,
    },
  };
}

function displayResults(results: GameResults): PrizeDistribution[] {
  console.log('\n' + '='.repeat(60));
  console.log('üéâ GAME COMPLETE!');
  console.log('='.repeat(60) + '\n');

  console.log('üìä FINAL RESULTS:\n');

  const sortedResults = Array.from(results.wins.entries())
    .sort((a, b) => b[1] - a[1]);

  const medals = ['ü•á', 'ü•à', 'ü•â'];
  sortedResults.forEach(([name, wins], index) => {
    const medal = medals[index] || 'üíÄ';
    console.log(`   ${medal} ${name}: ${wins} wins`);
  });

  console.log('\nüí∞ PRIZE DISTRIBUTION:\n');

  const prizes = calculatePrizes(sortedResults);
  prizes.forEach(({ name, change }) => {
    const sign = parseFloat(change) >= 0 ? '+' : '';
    console.log(`   ${name}: ${sign}${change} USDC`);
  });

  return prizes;
}

// ==================== MAIN ====================

async function main() {
  console.log('\nüéÆ TRIVIA ROYALE - Full Yellow SDK Integration\n');

  // ==================== SETUP PHASE ====================
  console.log('üìã SETUP PHASE\n');

  console.log('1. Loading wallets...\n');
  const wallets = loadWallets();
  const players = wallets.players;
  const server = wallets.server;

  console.log(`   ‚úÖ Loaded ${wallets.all.length} wallets`);
  players.forEach(p => console.log(`      - ${p.name}: ${p.address}`));
  console.log(`      - ${server.name}: ${server.address}\n`);

  // ==================== CLEARNODE CONNECTION ====================
  console.log('2. Connecting to ClearNode (off-chain)...\n');

  const allParticipants = [...players, server];
  const connections = await connectAllParticipants(allParticipants);

  console.log(`   ‚úÖ All ${connections.size} participants connected\n`);

  // ==================== CHANNEL CREATION ====================
  const channelIds = await setupChannelsViaRPC(players, connections);

  // ==================== PLAY GAME ====================
  console.log('3. Setting up game clients and playing...\n');

  const allParticipantsForSession = [...players, server];
  const initialAllocations: Array<{
    participant: `0x${string}`;
    asset: string;
    amount: string;
  }> = allParticipantsForSession.map(p => {
    // Players deposit entry fee, server starts with 0
    const isPlayer = players.some(player => player.address === p.address);
    return {
      participant: p.address,
      asset: SEPOLIA_CONFIG.game.asset,
      amount: isPlayer ? SEPOLIA_CONFIG.game.entryFee : '0',
    };
  });

  const { results, sessionId, gameClients } = await playGame(
    players,
    server,
    connections,
    allParticipantsForSession.map(p => p.address),
    initialAllocations,
    channelIds
  );

  // ==================== DISPLAY RESULTS ====================
  const prizes = displayResults(results);

  // ==================== CLEANUP ====================
  console.log('\nüîí CLEANUP PHASE\n');

  console.log('1. Closing application session...');

  // Convert prizes to final allocations for Yellow SDK
  // IMPORTANT: Must include ALL participants (not just winners) for ClearNode validation
  const prizeMap = new Map(prizes.map(p => [p.name, p.prize]));

  const finalAllocations = players.map(player => {
    const prizeAmount = prizeMap.get(player.name);
    return {
      participant: player.address,
      asset: SEPOLIA_CONFIG.game.asset,
      amount: prizeAmount || '0', // Winners get prize, losers get 0
    };
  });

  // Add server allocation (unchanged)
  finalAllocations.push({
    participant: server.address,
    asset: SEPOLIA_CONFIG.game.asset,
    amount: '0',
  });

  await gameClients.server.endGame(sessionId, finalAllocations);
  console.log('   ‚úÖ Session closed\n');

  console.log('2. Cleaning up game clients...');
  gameClients.server.cleanup();
  gameClients.players.forEach(client => client.cleanup());
  console.log('   ‚úÖ Clients cleaned up\n');

  console.log('3. Disconnecting from ClearNode...');
  disconnectAll(connections);
  console.log('   ‚úÖ All disconnected\n');

  console.log('‚úÖ GAME COMPLETE!\n');
  console.log('üí° Channel states updated off-chain via Yellow SDK');
  console.log('üìã Run `bun run status` to check balances\n');
}

main().catch(console.error);
</file>

<file path="prepare.ts">
/**
 * Preparation Script for Trivia Royale
 *
 * This script helps you prepare for running the game by:
 * - Generating mnemonic-based HD wallets
 * - Showing Master wallet address for funding
 * - Checking balances
 * - Testing ClearNode connectivity
 */

import { mnemonicToAccount } from 'viem/accounts';
import { formatEther, parseEther } from 'viem';
import {
  generateNewMnemonic,
  loadWallets,
  createPublicRpcClient,
  deriveAddress,
} from './utils/wallets';
import { SEPOLIA_CONFIG } from './utils/contracts';
import { env } from './env';
import { getUSDCBalance, formatUSDC, parseUSDC } from './utils/erc20';

const WALLET_NAMES = ['Funding', 'Broker', 'Server', 'Alice', 'Bob', 'Charlie', 'Diana', 'Eve'];

/**
 * Get broker private key (index 1) for docker-compose.yml
 */
function getBrokerPrivateKey(mnemonic: string): `0x${string}` {
  const account = mnemonicToAccount(mnemonic, { accountIndex: 1 });
  const hdKey = account.getHdKey();
  const privateKeyBytes = hdKey.privateKey;

  // Convert Uint8Array to hex string
  if (privateKeyBytes instanceof Uint8Array) {
    const hex = Array.from(privateKeyBytes)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
    return `0x${hex}` as `0x${string}`;
  }

  return privateKeyBytes as `0x${string}`;
}

async function main() {
  console.log('\nüéÆ TRIVIA ROYALE - Setup\n');

  // Check for existing mnemonic
  let mnemonic = env.MNEMONIC;

  if (!mnemonic) {
    console.log('‚ö†Ô∏è  GENERATING NEW MNEMONIC - SAVE THIS!\n');
    mnemonic = generateNewMnemonic();
    console.log(`${mnemonic}\n`);
    console.log('üìù Add to .env:');
    console.log(`MNEMONIC="${mnemonic}"\n`);

    // Show derived addresses (without full wallet loading)
    console.log('üë• Wallet Addresses (HD Path: m/44\'/60\'/N\'/0/0):\n');
    for (let i = 0; i < WALLET_NAMES.length; i++) {
      const address = deriveAddress(mnemonic, i);
      console.log(`   ${i}. ${WALLET_NAMES[i]?.padEnd(8)}: ${address}`);
    }

    // Show Broker configuration
    const brokerPrivateKey = getBrokerPrivateKey(mnemonic);
    const brokerAddress = deriveAddress(mnemonic, 1);

    console.log('\nüîë BROKER CONFIGURATION (Index 1 - for ClearNode):\n');
    console.log(`   Address:     ${brokerAddress}`);
    console.log(`   Private Key: ${brokerPrivateKey}`);
    console.log('\n   ‚ö†Ô∏è  IMPORTANT: Update docker-compose.yml with this private key:');
    console.log(`   Line 103: BROKER_PRIVATE_KEY: ${brokerPrivateKey}\n`);

    console.log('üìã Next Steps:');
    console.log('   1. Save MNEMONIC to .env file');
    console.log('   2. Update BROKER_PRIVATE_KEY in docker-compose.yml (see above)');
    console.log('   3. Fund Funding wallet (index 0) with:');
    console.log(`      - ${SEPOLIA_CONFIG.funding.fundingGasReserve} ETH from: https://faucets.chain.link/sepolia`);
    console.log(`      - ${SEPOLIA_CONFIG.funding.fundingGameReserve} USDC from: https://faucet.circle.com/`);
    console.log('   4. Start ClearNode: docker-compose up -d');
    console.log('   5. Run: bun run fund');
    console.log('   6. Run: bun run play\n');

    return;
  }

  // Existing mnemonic - show status
  console.log('‚úÖ Using existing MNEMONIC from .env\n');

  const wallets = loadWallets();
  const funding = wallets.funding;
  const broker = wallets.broker;
  const publicClient = createPublicRpcClient();

  // Show Broker configuration
  const brokerPrivateKey = getBrokerPrivateKey(mnemonic);
  console.log('üîë Broker Configuration:\n');
  console.log(`   Address:     ${broker.address}`);
  console.log(`   Private Key: ${brokerPrivateKey}`);
  console.log(`   Expected:    ${SEPOLIA_CONFIG.contracts.brokerAddress}`);
  if (broker.address.toLowerCase() !== SEPOLIA_CONFIG.contracts.brokerAddress.toLowerCase()) {
    console.log(`   ‚ö†Ô∏è  WARNING: Broker address mismatch! Update contracts.ts brokerAddress\n`);
  } else {
    console.log(`   ‚úÖ Matches contracts.ts configuration\n`);
  }

  // Check funding wallet balances (both ETH and USDC)
  const ethBalance = await publicClient.getBalance({ address: funding.address });
  const usdcBalance = await getUSDCBalance(funding, funding.address);

  console.log('üí∞ Funding Wallet:\n');
  console.log(`   Address: ${funding.address}`);
  console.log(`   ETH Balance:  ${formatEther(ethBalance)}`);
  console.log(`   USDC Balance: ${formatUSDC(usdcBalance)}\n`);

  const requiredEth = parseEther(SEPOLIA_CONFIG.funding.fundingGasReserve);
  const requiredUsdc = parseUSDC(SEPOLIA_CONFIG.funding.fundingGameReserve);

  const needsEth = ethBalance < requiredEth;
  const needsUsdc = usdcBalance < requiredUsdc;

  if (needsEth || needsUsdc) {
    console.log('‚ö†Ô∏è  FUNDING WALLET NEEDS FUNDING!\n');

    if (needsEth) {
      console.log(`   ETH Required:  ${SEPOLIA_CONFIG.funding.fundingGasReserve} ETH`);
      console.log(`   ETH Current:   ${formatEther(ethBalance)} ETH`);
      console.log('   üìã Get ETH from: https://faucets.chain.link/sepolia\n');
    }

    if (needsUsdc) {
      console.log(`   USDC Required: ${SEPOLIA_CONFIG.funding.fundingGameReserve} USDC`);
      console.log(`   USDC Current:  ${formatUSDC(usdcBalance)} USDC`);
      console.log('   üìã Get USDC from: https://faucet.circle.com/\n');
    }

    console.log(`   Send to: ${funding.address}\n`);
  } else {
    console.log('‚úÖ Funding wallet has sufficient funds\n');
    console.log('üìã Next Steps:');
    console.log('   1. Verify BROKER_PRIVATE_KEY in docker-compose.yml (see above)');
    console.log('   2. Start ClearNode: docker-compose up -d');
    console.log('   3. Run: bun run fund');
    console.log('   4. Run: bun run play\n');
  }
}

main().catch(console.error);
</file>

<file path="status.ts">
/**
 * Status Report Script
 *
 * Shows current status of all wallets:
 * - ETH balances (on-chain wallet balance)
 * - Off-chain ledger balances (ClearNode off-chain tracking)
 * - Custody balances (deposited in custody contract)
 * - Channel information (open channels, balances, participants)
 *
 * Usage:
 *   bun run status           # Show all wallets
 *   bun run status alice     # Show only Alice
 *   bun run status server    # Show only Server
 */

import { loadWallets, createPublicRpcClient, type Wallet } from './utils/wallets';
import { NitroliteClient, ChannelStatus } from '@erc7824/nitrolite';
import { SEPOLIA_CONFIG } from './utils/contracts';
import { connectToClearNode, authenticateClearNode } from './yellow-integration';
import { getLedgerBalances } from './utils/clearnode';
import { getUSDCBalance, formatUSDC } from './utils/erc20';
import { formatEther } from 'viem';

/**
 * Format USDC with more decimals for precision
 */
function formatUsdcBalance(wei: bigint): string {
  return formatUSDC(wei).padStart(14);
}

async function main() {
  console.log('\nüéÆ TRIVIA ROYALE - Status Report\n');
  console.log(`üíé USDC Token: ${SEPOLIA_CONFIG.contracts.tokenAddress}\n`);

  const wallets = loadWallets();
  const publicClient = createPublicRpcClient();

  // Parse filter argument (e.g., "alice", "bob1", "server")
  const filterName = process.argv[2]?.toLowerCase();

  let walletsToShow: Wallet[];
  if (filterName) {
    walletsToShow = wallets.all.filter(w => w.name.toLowerCase().includes(filterName));
    if (walletsToShow.length === 0) {
      console.log(`‚ùå No wallet found matching "${filterName}"`);
      console.log(`Available wallets: ${wallets.all.map(w => w.name).join(', ')}`);
      process.exit(1);
    }
    console.log(`Filtering: ${walletsToShow.map(w => w.name).join(', ')}\n`);
  } else {
    walletsToShow = wallets.all;
  }

  // Get wallet role icons
  const getRoleIcon = (name: string) => {
    switch (name) {
      case 'Funding': return 'üí∞';
      case 'Broker': return 'üè¶';
      case 'Server': return 'üéÆ';
      case 'Test': return 'üß™';
      case 'Test2': return 'üß¨';
      case 'Test3': return 'üî¨';
      case 'Test4': return '‚öóÔ∏è';
      case 'Test5': return 'üß´';
      case 'Test6': return 'üî≠';
      case 'Test7': return 'üßÆ';
      case 'Test8': return 'üîé';
      case 'Test9': return 'üî¨';
      case 'Test10': return '‚öõÔ∏è';
      default: return 'üë§';
    }
  };

  // Wallet balances (both ETH and USDC)
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('                                  WALLET BALANCES                                          ');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
  console.log('‚îÇ   ‚îÇ Wallet   ‚îÇ Address                                    ‚îÇ ETH (gas)    ‚îÇ USDC (game)  ‚îÇ');
  console.log('‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');

  for (const wallet of walletsToShow) {
    const ethBalance = await publicClient.getBalance({ address: wallet.address });
    const usdcBalance = await getUSDCBalance(wallet, wallet.address);

    const icon = getRoleIcon(wallet.name);
    const ethFormatted = formatEther(ethBalance).padStart(12);
    const usdcFormatted = formatUsdcBalance(usdcBalance);

    console.log(`‚îÇ ${icon} ‚îÇ ${wallet.name.padEnd(8)} ‚îÇ ${wallet.address} ‚îÇ ${ethFormatted} ‚îÇ ${usdcFormatted} ‚îÇ`);
  }

  console.log('‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n');

  // Off-chain ledger balances (from ClearNode)
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('                         OFF-CHAIN LEDGER BALANCES                             ');
  console.log('                   (Updated by ClearNode Application Sessions)                 ');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

  // Connect to ClearNode to get ledger balances
  const connections = new Map<string, WebSocket>();
  try {
    for (const wallet of walletsToShow) {
      const ws = await connectToClearNode(SEPOLIA_CONFIG.clearNodeUrl);
      await authenticateClearNode(ws, wallet);
      connections.set(wallet.name, ws);
    }

    // Display ledger balances
    for (const wallet of walletsToShow) {
      const ws = connections.get(wallet.name);
      if (!ws) continue;

      try {
        const ledgerBalances = await getLedgerBalances(ws, wallet);

        console.log(`‚îå‚îÄ ${wallet.name} (${wallet.address.slice(0, 10)}...${wallet.address.slice(-8)})`);

        if (ledgerBalances && ledgerBalances.length > 0) {
          ledgerBalances.forEach((balance: any) => {
            console.log(`‚îÇ  üíé ${balance.asset.toUpperCase()}: ${balance.amount}`);
          });
        } else {
          console.log(`‚îÇ  ‚ö†Ô∏è  No ledger balances found`);
        }

        console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n');
      } catch (error) {
        console.log(`‚îå‚îÄ ${wallet.name}`);
        console.log(`‚îÇ  ‚ö†Ô∏è  Error fetching ledger balance: ${error instanceof Error ? error.message : 'Unknown error'}`);
        console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n');
      }
    }
  } catch (error) {
    console.log(`‚ö†Ô∏è  Failed to connect to ClearNode: ${error instanceof Error ? error.message : 'Unknown error'}\n`);
  } finally {
    // Clean up connections
    for (const [name, ws] of connections) {
      if (ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
    }
  }

  // Channel status for each wallet
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('                      CUSTODY & CHANNELS                           ');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

  for (const wallet of walletsToShow) {
    try {
      // Create read-only NitroliteClient
      const client = new NitroliteClient({
        publicClient,
        walletClient: wallet.client,
        stateSigner: null as any, // Not needed for read operations
        challengeDuration: 3600n,
        addresses: {
          custody: SEPOLIA_CONFIG.contracts.custody,
          adjudicator: SEPOLIA_CONFIG.contracts.adjudicator,
          guestAddress: wallet.address, // Dummy, not used for reads
        },
        chainId: SEPOLIA_CONFIG.chainId,
      });

      // Get custody balance
      const custodyBalance = await client.getAccountBalance(SEPOLIA_CONFIG.contracts.tokenAddress);

      // Get open channels
      const channelIds = await client.getOpenChannels();

      console.log(`‚îå‚îÄ ${wallet.name} (${wallet.address.slice(0, 10)}...${wallet.address.slice(-8)})`);
      console.log(`‚îÇ  üí∞ Custody Balance: ${formatUsdcBalance(custodyBalance)} USDC`);
      console.log(`‚îÇ  üìä Open Channels: ${channelIds.length}`);

      if (channelIds.length > 0) {
        console.log('‚îÇ');
        for (let i = 0; i < channelIds.length; i++) {
          const channelId = channelIds[i];
          const channelData = await client.getChannelData(channelId);
          const channelBalance = await client.getChannelBalance(
            channelId,
            SEPOLIA_CONFIG.contracts.tokenAddress
          );

          // Find counterparty (the other participant)
          const counterparty = channelData.channel.participants.find(
            (addr) => addr.toLowerCase() !== wallet.address.toLowerCase()
          );

          // Map status enum to readable string
          const statusNames = ['VOID', 'INITIAL', 'ACTIVE', 'DISPUTE', 'FINAL'];
          const statusName = statusNames[channelData.status] || 'UNKNOWN';

          const prefix = i === channelIds.length - 1 ? '‚îî‚îÄ‚îÄ' : '‚îú‚îÄ‚îÄ';
          console.log(`‚îÇ  ${prefix} Channel ${channelId.slice(0, 10)}...`);
          console.log(`‚îÇ      ‚Ä¢ Status: ${statusName}`);
          console.log(`‚îÇ      ‚Ä¢ Counterparty: ${counterparty?.slice(0, 10)}...${counterparty?.slice(-8)}`);
          console.log(`‚îÇ      ‚Ä¢ Balance: ${formatUsdcBalance(channelBalance)} USDC`);
          console.log(`‚îÇ      ‚Ä¢ State Version: ${channelData.lastValidState.version}`);
          if (i < channelIds.length - 1) console.log('‚îÇ');
        }
      }

      console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n');
    } catch (error) {
      console.log(`‚îå‚îÄ ${wallet.name}`);
      console.log(`‚îÇ  ‚ö†Ô∏è  Error fetching channel data: ${error instanceof Error ? error.message : 'Unknown error'}`);
      console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n');
    }
  }
}

main().catch(console.error);
</file>

<file path="test-clearnode.ts">
/**
 * ClearNode Connection Test
 *
 * Tests WebSocket connection to ClearNode without creating channels.
 * This saves gas by validating ClearNode connectivity before on-chain operations.
 */

import { loadWallets } from './utils/wallets';
import { connectToClearNode, authenticateClearNode } from './yellow-integration';
import { SEPOLIA_CONFIG } from './utils/contracts';

async function main() {
  console.log('\nüß™ CLEARNODE CONNECTION TEST\n');

  // Load wallets
  const wallets = loadWallets();
  const alice = wallets.alice;

  console.log(`Testing URL: ${SEPOLIA_CONFIG.clearNodeUrl}`);
  console.log(`Wallet: ${alice.name} (${alice.address})\n`);

  try {
    // Step 1: Connect to ClearNode
    console.log('1. Connecting to ClearNode WebSocket...');
    const ws = await connectToClearNode(SEPOLIA_CONFIG.clearNodeUrl);
    console.log('   ‚úÖ WebSocket connected\n');

    // Step 2: Authenticate
    console.log('2. Authenticating with wallet signature...');
    await authenticateClearNode(ws, alice);
    console.log('   ‚úÖ Authentication successful\n');

    // Success!
    console.log('üéâ ClearNode test PASSED!\n');
    console.log('You can now run: bun run play\n');

    // Cleanup
    ws.close();
    process.exit(0);

  } catch (error) {
    console.error('\n‚ùå ClearNode test FAILED\n');
    console.error('Error:', error instanceof Error ? error.message : String(error));
    console.error('\nPossible causes:');
    console.error('- ClearNode server is offline');
    console.error('- URL is incorrect');
    console.error('- Network/firewall blocking WebSocket\n');
    process.exit(1);
  }
}

main();
</file>

<file path="test-config.ts">
/**
 * Test ClearNode Configuration
 *
 * This script calls the get_config RPC method to retrieve ClearNode's
 * broker address and network configuration, then compares it with our
 * local SEPOLIA_CONFIG.
 */

import { parseAnyRPCResponse, RPCMethod } from '@erc7824/nitrolite';
import { SEPOLIA_CONFIG } from './utils/contracts';

async function testGetConfig() {
  console.log('üîç Testing ClearNode Configuration\n');

  // Connect to ClearNode
  const ws = new WebSocket(SEPOLIA_CONFIG.clearNodeUrl);

  await new Promise<void>((resolve, reject) => {
    ws.onopen = () => {
      console.log('‚úÖ Connected to ClearNode\n');
      resolve();
    };
    ws.onerror = (error) => {
      console.error('‚ùå Connection error:', error);
      reject(error);
    };
    setTimeout(() => reject(new Error('Connection timeout')), 10000);
  });

  // Send get_config request (no auth required - it's a public method)
  const request = {
    req: [Date.now(), 'get_config', {}, Date.now()],
    sig: [],
  };

  console.log('üì§ Sending get_config request...\n');
  ws.send(JSON.stringify(request));

  // Wait for response
  await new Promise<void>((resolve, reject) => {
    const handleMessage = (event: MessageEvent) => {
      try {
        const response = parseAnyRPCResponse(event.data);
        console.log('üì® Received response:', JSON.stringify(response, null, 2));

        if (response.method === RPCMethod.GetConfig) {
          ws.removeEventListener('message', handleMessage);

          // Note: SDK parses field names to camelCase
          const { brokerAddress, networks } = response.params;

          console.log('\nüìä ClearNode Configuration:');
          console.log(`   Broker Address: ${brokerAddress}`);
          console.log(`   Networks: ${networks.length}\n`);

          // Find Sepolia network (using camelCase chainId)
          const sepoliaNetwork = networks.find((n: any) => n.chainId === SEPOLIA_CONFIG.chainId);

          console.log('üîç Comparing with our SEPOLIA_CONFIG:\n');

          console.log('   Broker Address:');
          console.log(`     Ours:      ${SEPOLIA_CONFIG.contracts.brokerAddress}`);
          console.log(`     ClearNode: ${brokerAddress}`);
          console.log(`     Match: ${SEPOLIA_CONFIG.contracts.brokerAddress.toLowerCase() === brokerAddress?.toLowerCase() ? '‚úÖ' : '‚ùå'}\n`);

          if (sepoliaNetwork) {
            console.log('   Sepolia Network (chain_id: 11155111):');
            console.log(`     Custody Contract:`);
            console.log(`       Ours:      ${SEPOLIA_CONFIG.contracts.custody}`);
            console.log(`       ClearNode: ${sepoliaNetwork.custodyAddress}`);
            console.log(`       Match: ${SEPOLIA_CONFIG.contracts.custody.toLowerCase() === sepoliaNetwork.custodyAddress?.toLowerCase() ? '‚úÖ' : '‚ùå'}\n`);

            console.log(`     Adjudicator Contract:`);
            console.log(`       Ours:      ${SEPOLIA_CONFIG.contracts.adjudicator}`);
            console.log(`       ClearNode: ${sepoliaNetwork.adjudicatorAddress}`);
            console.log(`       Match: ${SEPOLIA_CONFIG.contracts.adjudicator.toLowerCase() === sepoliaNetwork.adjudicatorAddress?.toLowerCase() ? '‚úÖ' : '‚ùå'}\n`);
          } else {
            console.log('   ‚ùå Sepolia network (chain_id: 11155111) NOT FOUND in ClearNode config!');
            console.log('   Available networks:');
            networks.forEach((n: any) => {
              console.log(`     - Chain ID: ${n.chainId}`);
            });
          }

          ws.close();
          resolve();
        } else if (response.method === RPCMethod.Error) {
          console.error('‚ùå ClearNode error:', response.params);
          ws.removeEventListener('message', handleMessage);
          ws.close();
          reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
        }
      } catch (error) {
        console.error('‚ùå Error parsing response:', error);
      }
    };

    ws.addEventListener('message', handleMessage);

    setTimeout(() => {
      ws.removeEventListener('message', handleMessage);
      ws.close();
      reject(new Error('Response timeout'));
    }, 10000);
  });
}

// Run the test
testGetConfig()
  .then(() => {
    console.log('\n‚úÖ Test completed');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\n‚ùå Test failed:', error);
    process.exit(1);
  });
</file>

<file path="yellow-integration.ts">
/**
 * Yellow SDK Integration Helpers
 *
 * This module provides helper functions for integrating with Yellow Network's
 * Nitrolite SDK, including:
 * - Connecting to ClearNode (WebSocket)
 * - Authenticating with ClearNode
 * - Managing application sessions
 * - Sending game messages
 */

import {
  createAuthRequestMessage,
  parseAnyRPCResponse,
  createAuthVerifyMessage,
  createEIP712AuthMessageSigner,
  createAppSessionMessage,
  createApplicationMessage,
  createCloseAppSessionMessage,
  createTransferMessage,
  RPCMethod,
  type PartialEIP712AuthMessage,
  type EIP712AuthDomain,
} from "@erc7824/nitrolite";
import { NitroliteRPC } from "@erc7824/nitrolite/dist/rpc/nitrolite";
import {
  type Address,
  type WalletClient,
  type Hex,
  toHex,
  keccak256,
} from "viem";
import { DEBUG } from "./env";
import type { Wallet } from "./utils/wallets";

// ==================== TYPES ====================

/**
 * Message signer function type
 * Used for signing ClearNode messages (application sessions, game messages)
 */
export type MessageSigner = (message: any) => Promise<Hex>;

export interface AppSessionInfo {
  sessionId: Hex;
  status: "pending" | "open" | "closed";
}

// ==================== CONSTANTS ====================

/**
 * EIP-712 domain for ClearNode authentication
 * Note: Must match app_name in auth request
 */
const AUTH_DOMAIN: EIP712AuthDomain = {
  name: "Test Domain",
};

// ==================== CLEARNODE CONNECTION ====================

/**
 * Connect to ClearNode WebSocket
 */
export async function connectToClearNode(
  clearNodeUrl: string
): Promise<WebSocket> {
  return new Promise((resolve, reject) => {
    const ws = new WebSocket(clearNodeUrl);

    ws.onopen = () => {
      console.log("  ‚úÖ Connected to ClearNode");
      resolve(ws);
    };

    ws.onerror = (error) => {
      console.error("  ‚ùå ClearNode connection error:", error);
      reject(error);
    };

    // Add timeout
    setTimeout(() => {
      if (ws.readyState !== WebSocket.OPEN) {
        ws.close();
        reject(new Error("ClearNode connection timeout"));
      }
    }, 10000);
  });
}

/**
 * Authenticate with ClearNode using EIP-712 typed signatures
 *
 * Uses the wallet's pre-generated session key for authentication.
 * This session key will be used for signing states and messages throughout the session.
 *
 * @param allowances - Optional allowances for app session funding. When provided,
 *                     authorizes ClearNode to use these amounts from ledger balances
 *                     for creating/updating application sessions.
 */
export async function authenticateClearNode(
  ws: WebSocket,
  wallet: Wallet,
  allowances: Array<{ asset: string; amount: string }> = []
): Promise<void> {
  return new Promise(async (resolve, reject) => {
    const account = wallet.client.account;
    if (!account) {
      reject(new Error("No account found in wallet"));
      return;
    }

    try {
      const walletAddress = account.address;
      const expireNum = Math.floor(Date.now() / 1000) + 3600;
      const expire = expireNum.toString(); // STRING for auth request (server expects string)

      if (DEBUG) {
        console.log(`  üîë Main wallet: ${walletAddress}`);
        console.log(`  üîê Session key: ${wallet.sessionAddress}`);
      }

      // Step 1: Send auth request with main wallet and session key
      const authRequest = await createAuthRequestMessage({
        address: walletAddress,                // Main wallet address
        session_key: wallet.sessionAddress,    // Session wallet address (from wallet)
        app_name: "Test Domain",
        expire, // Pass as string
        scope: "console",
        application: '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc', // random address, no use for now
        allowances,                            // Pass allowances (default: [])
      });

      if (DEBUG) {
        console.log(`  üì§ Sending auth request:`, authRequest);
      }
      ws.send(authRequest);

      // Step 2: Wait for challenge and authenticate
      const handleMessage = async (event: MessageEvent) => {
        try {
          // Parse response using SDK parser for type safety
          const response = parseAnyRPCResponse(event.data);

          if (DEBUG) {
            console.log(`  üì® Received ${response.method}:`, response.params);
          }

          switch (response.method) {
            case RPCMethod.AuthChallenge:
              // Create partial EIP-712 message (SDK will add challenge and wallet)
              // Note: expire as STRING matches official SDK tests
              const partialMessage = {
                scope: "console",
                application: '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc',
                participant: wallet.sessionAddress, // Session wallet address (not main!)
                expire, // STRING (matches official SDK integration tests)
                allowances,                         // Pass allowances (default: [])
              } satisfies PartialEIP712AuthMessage;

              // Create EIP-712 message signer (SDK handles signing)
              const signer = createEIP712AuthMessageSigner(
                wallet.client,
                partialMessage,
                AUTH_DOMAIN
              );

              // Send auth verification with full challenge response object
              const authVerify = await createAuthVerifyMessage(
                signer,
                response, // Full challenge response object
              );

              if (DEBUG) {
                console.log(`  üì§ Sending auth verify message:`, authVerify);
              }
              ws.send(authVerify);
              break;

            case RPCMethod.AuthVerify:
              if (response.params.success) {
                ws.removeEventListener("message", handleMessage);
                console.log(`  ‚úÖ Authentication successful`);

                // Store JWT if provided (debug only)
                if (DEBUG && response.params.jwtToken) {
                  console.log(`  üéüÔ∏è  Received JWT token`);
                  // TODO: Store JWT for future sessions
                }

                resolve();
              } else {
                ws.removeEventListener("message", handleMessage);
                reject(new Error("Authentication failed"));
              }
              break;

            case RPCMethod.Error:
              console.error("  ‚ùå ClearNode error:", response);
              ws.removeEventListener("message", handleMessage);
              reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
              break;
          }
        } catch (error) {
          console.error("  ‚ùå Error handling auth message:", error);
          // Don't reject here, might be a different message format
        }
      };

      ws.addEventListener("message", handleMessage);

      // Timeout
      setTimeout(() => {
        ws.removeEventListener("message", handleMessage);
        reject(new Error("Authentication timeout"));
      }, 30000);
    } catch (error) {
      reject(error);
    }
  });
}

// ==================== APPLICATION SESSIONS ====================

/**
 * Create an application session for the game
 * Game Master pattern: server controls game, players have no voting power
 */
export async function createGameSession(
  ws: WebSocket,
  signer: MessageSigner,
  participants: Address[],
  initialAllocations: Array<{
    participant: Address;
    asset: string;
    amount: string;
  }>,
  serverAddress: Address,
  protocol: string = 'NitroRPC/0.4'
): Promise<AppSessionInfo> {
  return new Promise(async (resolve, reject) => {
    console.log("\n  üéÆ Creating game session...");

    try {
      // Game Master pattern: players have weight 0, server has weight 100
      const weights = participants.map(p =>
        p.toLowerCase() === serverAddress.toLowerCase() ? 100 : 0
      );

      const sessionMsg = await createAppSessionMessage(signer, {
        definition: {
          protocol,
          participants,
          weights, // Server: 100, Players: 0
          quorum: 100, // Only server needs to agree
          challenge: 0,
          nonce: Date.now(),
        },
        allocations: initialAllocations,
      });

      // Send message
      ws.send(sessionMsg);
      console.log("  üì§ Sent session creation request");

      // Wait for response
      const handleMessage = (event: MessageEvent) => {
        try {
          const response = parseAnyRPCResponse(event.data);

          switch (response.method) {
            case RPCMethod.CreateAppSession:
              ws.removeEventListener("message", handleMessage);

              const sessionId = response.params.appSessionId;
              console.log(`  ‚úÖ Session created: ${sessionId}`);

              resolve({
                sessionId,
                status: "open",
              });
              break;

            case RPCMethod.Error:
              console.error("  ‚ùå ClearNode error:", response.params);
              ws.removeEventListener("message", handleMessage);
              reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
              break;
          }
        } catch (error) {
          console.error("  ‚ùå Error parsing session response:", error);
        }
      };

      ws.addEventListener("message", handleMessage);

      // Timeout
      setTimeout(() => {
        ws.removeEventListener("message", handleMessage);
        reject(new Error("Session creation timeout"));
      }, 30000);
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Create game session with multiple signatures (multi-party allocations)
 *
 * When creating an app session where multiple participants have non-zero allocations,
 * each participant with an allocation must sign the create_app_session request.
 *
 * This function:
 * 1. Creates the unsigned request message
 * 2. Collects signatures from server + all players with allocations
 * 3. Combines signatures into message.sig array
 * 4. Sends multi-signed message to ClearNode
 */
export async function createGameSessionWithMultiSig(
  ws: WebSocket,
  serverSigner: MessageSigner,
  playerSigners: Map<Address, MessageSigner>,
  participants: Address[],
  initialAllocations: Array<{
    participant: Address;
    asset: string;
    amount: string;
  }>,
  serverAddress: Address,
  protocol: string = 'NitroRPC/0.4'
): Promise<AppSessionInfo> {
  return new Promise(async (resolve, reject) => {
    console.log("\n  üéÆ Creating game session with multi-sig...");

    try {
      // Game Master pattern: players have weight 0, server has weight 100
      const weights = participants.map(p =>
        p.toLowerCase() === serverAddress.toLowerCase() ? 100 : 0
      );

      // Create unsigned request
      const request = NitroliteRPC.createRequest({
        method: RPCMethod.CreateAppSession,
        params: {
          definition: {
            protocol,
            participants,
            weights,
            quorum: 100,
            challenge: 0,
            nonce: Date.now(),
          },
          allocations: initialAllocations,
        },
        signatures: [], // Start with empty signatures
      });

      // Get the payload to sign
      if (!request.req) {
        reject(new Error("Failed to create request message"));
        return;
      }
      const payload = request.req;

      // Collect signatures from all participants with allocations
      const signatures: Hex[] = [];

      // Always include server signature first
      console.log("  üîè Collecting server signature...");
      const serverSig = await serverSigner(payload);
      signatures.push(serverSig);

      // Collect player signatures for those with allocations
      for (const allocation of initialAllocations) {
        if (allocation.amount !== '0') {
          const playerSigner = playerSigners.get(allocation.participant);
          if (!playerSigner) {
            reject(new Error(`No signer found for participant ${allocation.participant}`));
            return;
          }
          console.log(`  üîè Collecting signature from ${allocation.participant.slice(0, 10)}...`);
          const playerSig = await playerSigner(payload);
          signatures.push(playerSig);
        }
      }

      // Attach all signatures to message
      request.sig = signatures;
      console.log(`  ‚úÖ Collected ${signatures.length} signatures`);

      // Send multi-signed message
      ws.send(JSON.stringify(request));
      console.log("  üì§ Sent multi-signed session creation request");

      // Wait for response
      const handleMessage = (event: MessageEvent) => {
        try {
          const response = parseAnyRPCResponse(event.data);

          switch (response.method) {
            case RPCMethod.CreateAppSession:
              ws.removeEventListener("message", handleMessage);

              const sessionId = response.params.appSessionId;
              console.log(`  ‚úÖ Session created: ${sessionId}`);

              resolve({
                sessionId,
                status: "open",
              });
              break;

            case RPCMethod.Error:
              console.error("  ‚ùå ClearNode error:", response.params);
              ws.removeEventListener("message", handleMessage);
              reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
              break;
          }
        } catch (error) {
          console.error("  ‚ùå Error parsing session response:", error);
        }
      };

      ws.addEventListener("message", handleMessage);

      // Timeout
      setTimeout(() => {
        ws.removeEventListener("message", handleMessage);
        reject(new Error("Session creation timeout"));
      }, 30000);
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Send a game message via Yellow SDK's createApplicationMessage
 *
 * Uses method="message" with sid (session ID) for ClearNode routing.
 * ClearNode will broadcast to all session participants.
 */
export async function sendGameMessage(
  ws: WebSocket,
  signer: MessageSigner,
  sessionId: Hex,
  messageData: any
): Promise<void> {
  const appMessage = await createApplicationMessage(
    signer,
    sessionId,
    messageData
  );

  ws.send(appMessage);
}

/**
 * Close an application session
 */
export async function closeGameSession(
  ws: WebSocket,
  signer: MessageSigner,
  sessionId: Hex,
  finalAllocations: Array<{
    participant: Address;
    asset: string;
    amount: string;
  }>
): Promise<void> {
  return new Promise(async (resolve, reject) => {
    try {
      console.log("\n  üîí Closing game session...");

      const closeMsg = await createCloseAppSessionMessage(signer, {
        app_session_id: sessionId,
        allocations: finalAllocations,
      });

      // Setup listener for response
      const handleMessage = (event: MessageEvent) => {
        try {
          const response = parseAnyRPCResponse(event.data);
          if (response.method === RPCMethod.CloseAppSession) {
            console.log("  ‚úÖ Session closed");
            ws.removeEventListener("message", handleMessage);
            resolve();
          }
          if (response.method === RPCMethod.Error) {
            console.error("  ‚ùå ClearNode error:", response.params);
            ws.removeEventListener("message", handleMessage);
            reject(new Error(`ClearNode error: ${JSON.stringify(response.params)}`));
          }
        } catch (error) {
          // Ignore parsing errors, might be other messages
        }
      };

      // Set up timeout
      const timeoutId = setTimeout(() => {
        ws.removeEventListener("message", handleMessage);
        reject(new Error("Timeout closing session"));
      }, 10000);

      ws.addEventListener("message", handleMessage);
      ws.send(closeMsg);
      console.log("  ‚úÖ Session close request sent");
    } catch (error) {
      reject(error);
    }
  });
}

// ==================== UTILITIES ====================

/**
 * Create a message signer from a wallet
 *
 * This creates an ECDSA signer for general RPC methods (create_channel, etc.).
 * Pattern matches SDK's createECDSAMessageSigner but uses WalletClient instead of raw private key.
 *
 * Note: Auth messages use createEIP712AuthMessageSigner, other RPC methods use raw ECDSA.
 */
export function createMessageSigner(wallet: WalletClient): MessageSigner {
  return async (payload: any) => {
    if (!wallet.account) throw new Error("No account in wallet");

    // Match SDK's ECDSA signer pattern:
    // 1. JSON.stringify with BigInt handling
    // 2. Convert to hex
    // 3. Hash with keccak256
    // 4. Sign the hash directly (NOT signMessage which adds prefix)
    const message = toHex(
      JSON.stringify(payload, (_, v) =>
        typeof v === 'bigint' ? v.toString() : v
      )
    );

    const hash = keccak256(message);
    const signature = await wallet.account.sign?.({ hash });

    return signature;
  };
}
</file>

</files>
